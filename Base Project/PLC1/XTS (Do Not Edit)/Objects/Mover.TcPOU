<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.11">
  <POU Name="Mover" Id="{461a92b9-026e-4cbb-aa50-b18297f25ecc}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'reflection'}
FUNCTION_BLOCK Mover IMPLEMENTS iMover;

VAR_INPUT
	
	Mediator				: REFERENCE TO Mediator;
	MotionParameters		: MotionParameters_typ;		// Motion parameters used by internal motion function blocks
	SourceInstancePath		: STRING	:= 'Direct access';					// Used internally to temporarily store the source of a Mover method call for logging purposes. Don't read or write

END_VAR
VAR_OUTPUT
	
	Ready			: BOOL;			// Mover is enabled and ready to accept motion commands
	Busy			: BOOL;			// Mover is processing a command or changing state
	
	Error			: BOOL;			// error is currently active
	ErrorID			: UDINT;		// errorID of the active error
	ErrorOrigin		: STRING;		// error source, in case of errored internal function block
	
	InGroup			: BOOL;			// Mover is currently grouped for CA
	IdentInGroup	: UDINT;		// IDX within group, for knowing which movers are adjacent
	
	AxisReference	: AXIS_REF;		// Motion link variable. Left as output so the link can be made directly, and accessed by external code
	
	TrackInfo		: TrackInfo;	// Track information as read from MC_ReadTrackPositions

END_VAR
VAR
	{attribute 'instance-path'}
	{attribute 'noinit'}
	{attribute 'hide'}
	InstancePath		: STRING;	// instance naming, for diagnostics purposes
	
	LocalVars	: InternalMoverVars_typ;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Methods" Id="{d146b766-1176-40b7-a641-ffa579406c77}" />
    <Folder Name="Properties" Id="{9b9301bf-13c1-4ce0-91ab-e61950dfd74a}" />
    <Method Name="ActivateTrack" Id="{2cd7eff7-09ea-0845-346b-196f53ea2e60}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD ActivateTrack : BOOL
VAR_INPUT
	Track	: REFERENCE TO Track;
END_VAR
VAR
	newCallTime			: LREAL;
END_VAR
VAR_INST
	MsgCreate			: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// active the track for this mover
// THIS ROUTINE IS NOT CHAINABLE wait for .IsTrackReady before issuing additional motion commands

// this routine only stores data and sets flags
// actual work of activating the track is done in .CyclicTrack()
// to enable this to be called on every scan, a check is made here for not busy as MC_ActivateTrack does not handle multiple calls efficently
// .CyclicTrack() monitors for a falling edge on internalActivateTrack before allowing another command
// this functionality mimics motion library commands such as MC_MoveAbsolute

// do not re-activate track if it is already selected
IF (LocalVars.Track = 0 OR (LocalVars.Track <> 0 AND_THEN Track.Id <> LocalVars.Track^.Id)) THEN
	LocalVars.ActivateTrackFlag := TRUE;
	IF (LocalVars.TrackState = TrackState.WAIT_FOR_COMMAND) THEN
		LocalVars.ActivatingTrack := ADR(Track);
		LocalVars.TrackIsReady := FALSE;
		
		newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
		
		IF ( newCallTime - LocalVars.lastCallActivateTrack ) > 1 THEN
			MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverActivateTrack,0 );
			MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddInt(LocalVars.ActivatingTrack^.Id).AddString(THIS^.SourceInstancePath).AddString(Track.InstancePath);
			MsgCreate.Send(0);
		END_IF
		
		LocalVars.lastCallActivateTrack		:= newCallTime;
	END_IF;
END_IF;]]></ST>
      </Implementation>
    </Method>
    <Property Name="CurrentDestinationPosition" Id="{6d470b15-bd31-4ad6-8559-906c2c8d720c}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY CurrentDestinationPosition : LREAL]]></Declaration>
      <Get Name="Get" Id="{bc93c9f7-92a5-426e-9c7f-5953d1b7c034}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[
CurrentDestinationPosition		:= LocalVars.CurrentDestPosition;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="CurrentDestinationTrack" Id="{f44717ff-7baf-0aa6-3174-9f719de28f4d}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY CurrentDestinationTrack : DINT]]></Declaration>
      <Get Name="Get" Id="{8c28783f-5955-0092-0fca-8afe86f48bde}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[CurrentDestinationTrack := LocalVars.CurrentDestStation.TrackId;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="CurrentMoveType" Id="{97c82f4e-fad3-4ecf-8f48-6f47f3a34a61}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY CurrentMoveType : MoverCommandType_enum]]></Declaration>
      <Get Name="Get" Id="{008a2288-6099-47d9-88ab-640a99950162}">
        <Declaration><![CDATA[VAR
	MoverCurrentMoveType: MoverCommandType_enum;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[
CurrentMoveType		:= LocalVars.CurrentMoveType;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="CurrentObjective" Id="{b06cf2ff-b1dd-4afb-af24-76820a9809f8}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY CurrentObjective : String]]></Declaration>
      <Get Name="Get" Id="{39f22891-e1d0-4fbf-9032-2bbc45b18310}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[
CurrentObjective		:= LocalVars.CurrentDestObjective;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="CurrentTrack" Id="{57746913-d241-0290-0366-208479410de1}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY CurrentTrack : POINTER TO Track]]></Declaration>
      <Get Name="Get" Id="{845db4a8-12f5-01df-23b2-2ce5c8663c6a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[CurrentTrack := LocalVars.Track;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Cyclic" Id="{39769063-232f-402c-8c9b-ad47db196752}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD Cyclic : iMover
VAR_IN_OUT
	GroupReference		: AXES_GROUP_REF;
END_VAR
VAR
	runCyclicTrack		: BOOL;
END_VAR
VAR_INST
	MsgCreate			: FB_TcMessage;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// this method contains multiple state machines denoted by the headers below

// *************************************************************************
// mover state machine
// *************************************************************************

// cleans motion parameters, removing possible negatives. Upper bounds are capped by the axis parameters
MotionParameters.Acceleration	:= LIMIT( 0, MotionParameters.Acceleration, 1E300 );
MotionParameters.Deceleration	:= LIMIT( 0, MotionParameters.Deceleration, 1E300 );
MotionParameters.Jerk			:= LIMIT( 0, MotionParameters.Jerk, 1E300 );
MotionParameters.Velocity		:= LIMIT( 0, MotionParameters.Velocity, 1E300 );

CASE LocalVars.State OF
	MV_IDLE:	// ------------------------------------------------------- idle state
	
		Ready	:= FALSE;
		Busy	:= FALSE;

		LocalVars.Disable			:= FALSE;
		IF LocalVars.Enable THEN
			// clear enable on commands (allows commands to hold error IDs until next enable signle for debugging
			
			LocalVars.Reissue					:= FALSE;
			LocalVars.fbMoveAbsCA[0].Execute			:= FALSE;
			LocalVars.fbMoveAbsCA[1].Execute			:= FALSE;
			LocalVars.fbMoveRelCA[0].Execute			:= FALSE;
			LocalVars.fbMoveRelCA[1].Execute			:= FALSE;
			LocalVars.fbGearInPosMoverCA[0].Execute	:= FALSE;
			LocalVars.fbGearInPosMoverCA[1].Execute	:= FALSE;
			LocalVars.fbGearInPosAxisCA[0].Execute	:= FALSE;
			LocalVars.fbGearInPosAxisCA[1].Execute	:= FALSE;
			LocalVars.fbHaltCA.Execute				:= FALSE;
			LocalVars.fbAddToGroup.Execute			:= FALSE;
			LocalVars.fbRemoveFromGroup.Execute		:= FALSE;
			LocalVars.fbReset.Execute					:= FALSE;
			LocalVars.fbActivateTrack.Execute		:= FALSE;
		
			LocalVars.Enable		:= FALSE;
			LocalVars.State		:= MV_RESET;
		END_IF
		
	MV_RESET: // ------------------------------------------------------- axis is resetting
	
		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;
		
		LocalVars.fbReset.Execute			:= TRUE;
		
		IF LocalVars.fbReset.Done THEN
			LocalVars.fbReset.Execute		:= FALSE;
			Mediator.DetectMover1();
			LocalVars.State		:= MV_M1_DELAY;
		ELSIF LocalVars.fbReset.Error THEN
			ErrorID				:= LocalVars.fbReset.ErrorID;
			ErrorOrigin			:= CONCAT( InstancePath, '.fbReset' );
			LocalVars.State		:= MV_ERROR;		
		END_IF
		
	MV_M1_DELAY:	// ------------------------------------------------------ delay to allow M1 Detect Completion
	
		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;
		
		LocalVars.fbDelayM1Timer( IN := Mediator.EnvironmentIsReady AND_THEN (Mediator.Mover1DetectionComplete OR Mediator.XPU.GetMoverIdDetectionMode() = MoverIdDetectionMode.Standard), PT := T#500MS );
		
		IF LocalVars.fbDelayM1Timer.Q THEN
			LocalVars.fbDelayM1Timer( IN := FALSE );
			LocalVars.State	:= MV_ENABLING;
		END_IF
		
		// on mover 1 detection error disable the mover and report the error
		IF (Mediator.Mover1DetectionError) THEN
			// make sure the timer is reset
			LocalVars.fbDelayM1Timer( IN := FALSE );
			// log the error and transition to the error state
			ErrorOrigin				:= CONCAT( Mediator.InstancePath, '.Mover1DetectionError' );
			LocalVars.State := MV_ERROR;
		END_IF
			
	MV_ENABLING: // ------------------------------------------------------- axis is enabling
	
		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;
		
		LocalVars.fbPower.Enable					:= TRUE;
		LocalVars.fbPower.Enable_Positive			:= TRUE;
		LocalVars.fbPower.Enable_Negative			:= TRUE;
		LocalVars.fbPower.BufferMode				:= MC_Aborting;
		LocalVars.fbPower.Override				:= 100;
		
		IF LocalVars.fbPower.Status THEN
			LocalVars.State				:= MV_ADDTOGROUP;
		ELSIF LocalVars.fbPower.Error THEN
			ErrorID						:= LocalVars.fbPower.ErrorID;
			ErrorOrigin					:= CONCAT( InstancePath, '.fbPower' );
			LocalVars.State				:= MV_ERROR;
		ELSIF AxisReference.Status.Error THEN
			ErrorID					:= AxisReference.Status.ErrorID;
			ErrorOrigin				:= Concat(InstancePath, ': General NC Error during Enabling');
			LocalVars.State			:= MV_ERROR;
		END_IF
		
	MV_ADDTOGROUP: // ------------------------------------------------------- axis is adding to a group
	
		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;
		
		// add to group is done in batches controlled by the mediator
		LocalVars.fbAddToGroup.Execute			:= LocalVars.MoverIndex <= Mediator.GroupAddLimit;
		LocalVars.fbAddToGroup.IdentInGroup		:= UDINT_TO_IDENTINGROUP( AxisReference.NcToPlc.AxisId - 1 );
		
		// wait for done and secondary check of number of movers (fb may report done before NC is done with high mover counts)
		IF LocalVars.fbAddToGroup.Done AND Mediator.GroupAxesCount = Mediator.NumMovers THEN
			// all axes added to group, move to next state
			InGroup						:= TRUE;
			IdentInGroup				:= AxisReference.NcToPlc.AxisId - 1;
			LocalVars.fbAddToGroup.Execute		:= FALSE;
			LocalVars.State				:= MV_ENABLEGROUP;
		ELSIF LocalVars.fbAddToGroup.Error THEN
			// error with add to group fb
			LocalVars.fbAddToGroup.Execute		:= FALSE;
			ErrorID						:= LocalVars.fbAddToGroup.ErrorId;
			ErrorOrigin					:= CONCAT( InstancePath, '.fbAddToGroup' );
			LocalVars.State				:= MV_ERROR;
		ELSIF AxisReference.Status.Error THEN
			// error reported by the axis
			LocalVars.fbAddToGroup.Execute		:= FALSE;
			ErrorID					:= AxisReference.Status.ErrorID;
			ErrorOrigin				:= Concat(InstancePath, ': General NC Error during add to group');
			LocalVars.State			:= MV_ERROR;
		END_IF
		
	MV_ENABLEGROUP:	// ----------------------------------------------- have mediator enable group
		Mediator.EnableGroup();
		IF Mediator.GroupEnabled AND Mediator.AllMotorModulesReady THEN
			LocalVars.State := MV_RUN;
		ELSIF Mediator.Error THEN
			Error			:= TRUE;
			ErrorID			:= Mediator.ErrorID;
			ErrorOrigin		:= Concat(InstancePath, ': Mediator.EnableGroup');
			LocalVars.State	:= MV_ERROR;;
		END_IF
			
	MV_RUN: // ------------------------------------------------------- mover enabled, ready
	
		Ready	:= TRUE;
		IF NOT LocalVars.fbMoveAbsCA[0].busy AND NOT LocalVars.fbMoveAbsCA[1].Busy AND NOT LocalVars.fbMoveRelCA[0].Busy AND NOT LocalVars.fbMoveRelCA[1].Busy THEN 
			Busy	:= FALSE;
		ELSE
			Busy 	:= TRUE;
		END_IF
		Error	:= FALSE;
		ErrorID	:= 0;
		
		LocalVars.Enable			:= FALSE;		
		IF LocalVars.Disable THEN
			LocalVars.Disable		:= FALSE;
			LocalVars.State		:= MV_BEGIN_HALTING;
			
		// Reset all commands issued by method calls
		ELSIF LocalVars.fbMoveAbsCA[0].Busy OR LocalVars.fbMoveAbsCA[0].CommandAborted THEN // OR fbMoveAbs.CommandAborted THEN
			LocalVars.fbMoveAbsCA[0].Execute		:= FALSE;
		ELSIF LocalVars.fbMoveAbsCA[1].Busy OR LocalVars.fbMoveAbsCA[1].CommandAborted THEN
			LocalVars.fbMoveAbsCA[1].Execute		:= FALSE;			
		ELSIF LocalVars.fbAddToGroup.Done THEN
			LocalVars.fbAddToGroup.Execute		:= FALSE;
		ELSIF LocalVars.fbMoveRelCA[0].Busy OR LocalVars.fbMoveRelCA[0].CommandAborted THEN
			LocalVars.fbMoveRelCA[0].Execute		:= FALSE;
		ELSIF LocalVars.fbMoveRelCA[1].Busy OR LocalVars.fbMoveRelCA[1].CommandAborted THEN
			LocalVars.fbMoveRelCA[1].Execute		:= FALSE;
		ELSIF LocalVars.fbGearInPosMoverCA[0].Busy OR LocalVars.fbGearInPosMoverCA[0].CommandAborted THEN
			LocalVars.fbGearInPosMoverCA[0].Execute	:= FALSE;
		ELSIF LocalVars.fbGearInPosMoverCA[1].Busy OR LocalVars.fbGearInPosMoverCA[1].CommandAborted THEN
			LocalVars.fbGearInPosMoverCA[1].Execute	:= FALSE;
		ELSIF LocalVars.fbGearInPosAxisCA[0].Busy OR LocalVars.fbGearInPosAxisCA[0].CommandAborted THEN
			LocalVars.fbGearInPosAxisCA[0].Execute	:= FALSE;
		ELSIF LocalVars.fbGearInPosAxisCA[1].Busy OR LocalVars.fbGearInPosAxisCA[1].CommandAborted THEN
			LocalVars.fbGearInPosAxisCA[1].Execute	:= FALSE;
		ELSIF LocalVars.fbHaltCA.Busy OR LocalVars.fbHaltCA.CommandAborted OR LocalVars.fbHaltCA.Done THEN
			LocalVars.fbHaltCA.Execute			:= FALSE;
		END_IF;
		
		runCyclicTrack := TRUE;
		
		IF (LocalVars.Reissue) THEN
			THIS^.SourceInstancePath	:= 'ReissueCommand';

			CASE LocalVars.CurrentMoveType OF
				MOVETYPE_NONE:
					// No current command to reissue	
				MOVETYPE_POSITION:
					THIS^.MoveToPosition( LocalVars.CurrentDestPosition );
				MOVETYPE_STATION:
					THIS^.MoveToStation( LocalVars.CurrentDestStation );
				MOVETYPE_VELOCITY:
					THIS^.MoveVelocity( MotionParameters.Velocity );
				MOVETYPE_SYNC_MOVER:
					THIS^.SyncToMover( LocalVars.MasterMover, LocalVars.Gap );
				MOVETYPE_SYNC_AXIS:
					// This command should perhaps not be compatible with Reissue command
			END_CASE
			LocalVars.Reissue := FALSE;
		END_IF

		// And catch all internal function block errors
		IF LocalVars.fbMoveAbsCA[0].Error THEN
			ErrorID					:= LocalVars.fbMoveAbsCA[0].ErrorID;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbMoveAbs[0]' );
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbMoveAbsCA[1].Error THEN
			ErrorID					:= LocalVars.fbMoveAbsCA[1].ErrorId;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbMoveAbs[1]' );
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbAddToGroup.Error THEN
			ErrorID					:= LocalVars.fbAddToGroup.ErrorID;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbAddToGroup' );
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbMoveRelCA[0].Error THEN
			ErrorID					:= LocalVars.fbMoveRelCA[0].ErrorID;
			ErrorOrigin 			:= CONCAT ( InstancePath, '.fbMoveRelCA[0]');
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbMoveRelCA[1].Error THEN
			ErrorID					:= LocalVars.fbMoveRelCA[1].ErrorID;
			ErrorOrigin 			:= CONCAT ( InstancePath, '.fbMoveRelCA[1]');
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbGearInPosMoverCA[0].Error THEN
			ErrorID					:= LocalVars.fbGearInPosMoverCA[0].ErrorId;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbGearInPosMoverCA[0]');
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbGearInPosMoverCA[1].Error THEN
			ErrorID					:= LocalVars.fbGearInPosMoverCA[1].ErrorId;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbGearInPosMoverCA[1]');
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbGearInPosAxisCA[0].Error THEN
			ErrorID					:= LocalVars.fbGearInPosAxisCA[0].ErrorId;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbGearInPosAxisCA[0]');
			LocalVars.State			:= MV_ERROR;
		ELSIF LocalVars.fbGearInPosAxisCA[1].Error THEN
			ErrorID					:= LocalVars.fbGearInPosAxisCA[1].ErrorId;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbGearInPosAxisCA[1]');
			LocalVars.State			:= MV_ERROR;			
		ELSIF LocalVars.fbActivateTrack.Error THEN
			ErrorID					:= LocalVars.fbActivateTrack.ErrorId;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbActivateTrack');
			LocalVars.State			:= MV_ERROR;
		ELSIF AxisReference.Status.Error THEN
			ErrorID					:= AxisReference.Status.ErrorID;
			ErrorOrigin				:= Concat(InstancePath, ': General NC Error during run');
			LocalVars.State			:= MV_ERROR;
		END_IF
		
	MV_BEGIN_HALTING:	// --------------------------------------------------- begin stopping process
	
		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;
		
		// Kill any active motion commands
		LocalVars.fbMoveAbsCA[0].Execute			:= FALSE;
		LocalVars.fbMoveAbsCA[1].Execute			:= FALSE;
		LocalVars.fbMoveRelCA[0].Execute			:= FALSE;
		LocalVars.fbMoveRelCA[1].Execute			:= FALSE;
		LocalVars.fbGearInPosMoverCA[0].Execute	:= FALSE;
		LocalVars.fbGearInPosMoverCA[1].Execute	:= FALSE;
		LocalVars.fbGearInPosAxisCA[0].Execute	:= FALSE;
		LocalVars.fbGearInPosAxisCA[1].Execute	:= FALSE;

		
		IF Mediator.Error = FALSE THEN
			LocalVars.fbHaltCA.Execute		:= TRUE;
			//fbHaltCA.Deceleration	:= MotionParameters.Deceleration;
			//fbHaltCA.Jerk			:= MotionParameters.Jerk;
		ELSE
			LocalVars.State			:= MV_REMOVEFROMGROUP;
		END_IF;
		
		IF LocalVars.fbHaltCA.Active OR LocalVars.fbHaltCA.Done THEN
			LocalVars.State			:= MV_HALTING;
		ELSIF LocalVars.fbHaltCA.Error THEN
			ErrorID					:= LocalVars.fbHaltCA.ErrorID;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbHalt' );
			LocalVars.State			:= MV_ERROR;				
		END_IF	
		
	MV_HALTING:	// ------------------------------------------------------- mover disabling
	
		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;

		// Wait for the stopping action to complete
		IF LocalVars.fbHaltCA.Done THEN
			LocalVars.fbHaltCA.Execute		:= FALSE;
			LocalVars.State			:= MV_REMOVEFROMGROUP;
		ELSIF LocalVars.fbHaltCA.Error THEN
			ErrorID					:= LocalVars.fbHaltCA.ErrorID;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbHalt' );
			LocalVars.State			:= MV_ERROR;
		END_IF	
		
	MV_REMOVEFROMGROUP:	// ---------------------------------------------------- remove mover from CA group
	
		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;
		
		LocalVars.fbRemoveFromGroup.Execute			:= TRUE;
		LocalVars.fbRemoveFromGroup.IdentInGroup		:= UDINT_TO_IDENTINGROUP( IdentInGroup );
		
		IF LocalVars.fbRemoveFromGroup.Done THEN
			LocalVars.fbRemoveFromGroup.Execute		:= FALSE;
			InGroup							:= FALSE;
			LocalVars.State					:= MV_DISABLING;
		END_IF
		


	MV_DISABLING:	// ----------------------------------------------------- start the disabling process

		Ready	:= FALSE;
		Busy	:= TRUE;
		Error	:= FALSE;
		ErrorID	:= 0;
		
		LocalVars.fbPower.Enable				:= FALSE;
		LocalVars.fbPower.Enable_Positive		:= FALSE;
		LocalVars.fbPower.Enable_Negative		:= FALSE;
		LocalVars.fbPower.BufferMode			:= MC_Aborting;
		LocalVars.fbPower.Override			:= 100;
			
		IF LocalVars.fbPower.Status = FALSE THEN
			LocalVars.State			:= MV_IDLE;
		ELSIF LocalVars.fbPower.Error THEN
			ErrorID					:= LocalVars.fbPower.ErrorID;
			ErrorOrigin				:= CONCAT( InstancePath, '.fbPower' );
			LocalVars.State			:= MV_ERROR;
		END_IF		
	
	MV_ERROR: // ------------------------------------------------------- mover in error state
	
		Ready	:= FALSE;
		Busy	:= FALSE;
		Error	:= TRUE;
		
		LocalVars.CurrentMoveType:= MOVETYPE_NONE;
		
		LocalVars.Enable			:= FALSE;		
		IF LocalVars.Disable THEN
			LocalVars.Disable		:= FALSE;
			LocalVars.State		:= MV_REMOVEFROMGROUP;
			ErrorOrigin			:= '';
		END_IF
		
END_CASE

LocalVars.fbPower( Axis := AxisReference );
LocalVars.fbReset( Axis := AxisReference );

LocalVars.fbHaltCA( Axis := AxisReference );
//fbDisable( Axis := AxisRef );
//fbExternEnable( Axis := AxisRef );

LocalVars.fbAddToGroup( AxesGroup := GroupReference, Axis := AxisReference );
LocalVars.fbRemoveFromGroup( AxesGroup := GroupReference );

LocalVars.fbMoveAbsCA[0]( Axis := AxisReference );
LocalVars.fbMoveAbsCA[1]( Axis := AxisReference );
LocalVars.fbMoveRelCA[0] ( Axis := AxisReference );
LocalVars.fbMoveRelCA[1] ( Axis := AxisReference );

LocalVars.fbGearInPosMoverCA[0]( Master := LocalVars.MasterMover.AxisReference, Slave := THIS^.AxisReference );
LocalVars.fbGearInPosMoverCA[1]( Master := LocalVars.MasterMover.AxisReference, Slave := THIS^.AxisReference );

LocalVars.fbGearInPosAxisCA[0]( Master := LocalVars.MasterAxis, Slave := THIS^.AxisReference );
LocalVars.fbGearInPosAxisCA[1]( Master := LocalVars.MasterAxis, Slave := THIS^.AxisReference );

// track management
LocalVars.fbActivateTrack(Axis := AxisReference);
LocalVars.fbReadTrackPositions(Axis := AxisReference);

// *************************************************************************
// track management state machine
// *************************************************************************

// called by .Cyclic() to handle the MC_ActivateTrack call's required state machine
// this is only called while the mover is in the RUN state within .Cyclic() by design
// calling the track management functions on disabled or errored movers that are not
// assigned to a group just causes the track management functions to throw more errors

// .internalTrack and thus the property .CurrentTrack are not updated until the track transition is complete
// this is deliberate. The timing of a track change reuqires at least 2 PLC scans. If .internalTrack were
// to be set to an invalid track number during these transitions checking for mover presence at
// stations and zones would cause movers to "disappear" during the transition which may cause
// upstream movers to be released erroniously because the station/zone momentarily appears clear

// in user code .IsTrackReady and .CurrentTrack should be queried together before issuing commands to a mover
IF (runCyclicTrack) THEN
	CASE LocalVars.TrackState OF
		// wait for command
		TrackState.WAIT_FOR_COMMAND:
			IF (LocalVars.ActivateTrackFlag AND LocalVars.ActivatingTrack <> 0 AND_THEN LocalVars.ActivatingTrack^.isInitialized) THEN
				// unregister mover from current track (logical tracking)
				IF (LocalVars.Track <> 0) THEN
					LocalVars.Track^.UnregisterMover(THIS^);
				END_IF;
	
				// set flags
				LocalVars.TrackIsReady := FALSE;
	
				// advance state
				LocalVars.TrackState := TrackState.SETUP_FUNCTION;
			END_IF
			
		// setup and call the function
		TrackState.SETUP_FUNCTION:
			LocalVars.fbActivateTrack.TrackId := LocalVars.ActivatingTrack^.OTCID;
			LocalVars.fbActivateTrack.Execute := TRUE;
			IF (LocalVars.fbActivateTrack.Busy) THEN
				LocalVars.fbActivateTrack.Execute := FALSE;
				LocalVars.TrackState := TrackState.MONITOR_RESPONSE;
			END_IF
		
		// monitor response	
		TrackState.MONITOR_RESPONSE:
			IF (LocalVars.fbActivateTrack.Error) THEN
				LocalVars.TrackState := TrackState.ERROR;
			ELSIF (LocalVars.fbActivateTrack.Done) THEN
				LocalVars.TrackState := TrackState.REQUIRED_DELAY;
			END_IF;
		
		// required delay
		// the FB has returned .Done but the change has not yet propigated to the NC
		TrackState.REQUIRED_DELAY:
			LocalVars.TrackStateDelay.IN := TRUE;
			IF (LocalVars.TrackStateDelay.Q) THEN
				LocalVars.TrackStateDelay.IN := FALSE;
				LocalVars.TrackState := TrackState.CLEAN_UP;
			END_IF;
		
		// clean up flags
		TrackState.CLEAN_UP:
			LocalVars.Track := LocalVars.ActivatingTrack;
			LocalVars.TrackIsReady := TRUE;
			MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverActivateTrackComplete, 0);
			MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddInt(THIS^.CurrentTrack^.Id);
			MsgCreate.Send(0);
			// register mover
			LocalVars.Track^.RegisterMover(THIS^);
			LocalVars.TrackState := TrackState.WAIT_END;
			
		TrackState.ERROR:
			// reset execute
			LocalVars.fbActivateTrack.Execute := FALSE;
			// GVL.ERROR_TRACK is intentionally left in place
			// internalTrackIsReady is left at false
			// error is recorded in Cyclic()
			LocalVars.TrackState := TrackState.WAIT_END;
			
		TrackState.WAIT_END: 
			// falling edge detection for internalActivateTrackFlag
			IF (NOT LocalVars.ActivateTrackFlag) THEN
				LocalVars.TrackState := TrackState.WAIT_FOR_COMMAND;	
			END_IF
			LocalVars.ActivateTrackFlag := FALSE;
	
	END_CASE
	
	// read back track information
	IF (LocalVars.TrackIsReady AND LocalVars.Track <> 0) THEN
		// track info should be stable, call the block
		LocalVars.fbReadTrackPositions.Enable := TRUE;
		// copy data when ready
		IF (LocalVars.fbReadTrackPositions.Valid) THEN
			IF (LocalVars.Track^.Id <> 0) THEN
				TrackInfo.TrackPosition := LocalVars.fbReadTrackPositions.TrackPosition;
				TrackInfo.PartPosition := LocalVars.fbReadTrackPositions.PartPosition;
				TrackInfo.TrackId := LocalVars.fbReadTrackPositions.TrackId;
				TrackInfo.PartId := LocalVars.fbReadTrackPositions.PartId;
			ELSE
				TrackInfo.TrackPosition := AxisReference.NcToPlc.ModuloActPos;
				TrackInfo.PartPosition := AxisReference.NcToPlc.ModuloActPos;
				TrackInfo.TrackId := 0;
				TrackInfo.PartId := 0;
			END_IF
		END_IF
	ELSE
		// don't call function block to allow it to reset
		LocalVars.fbReadTrackPositions.Enable := FALSE;
	END_IF
	
	
	// a delay is required after MC_ActivateTrack returns .Done
	LocalVars.TrackStateDelay(PT := T#10MS);
END_IF;

// clear cyclic track run command and wait for it to be re-enabled by the first state machine
runCyclicTrack := FALSE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Disable" Id="{2aa14795-54cd-46b8-a131-b1a8801c005f}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD Disable : iMover
VAR_INPUT
END_VAR
VAR
END_VAR
VAR_INST
	MsgCreate	: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF LocalVars.State = MV_RUN OR LocalVars.State = MV_ERROR THEN

	// Sets an internal flag to advance the state machine
	LocalVars.Disable		:= TRUE;
	
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverDisable,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath);
	MsgCreate.Send(0);	
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

Disable		:= THIS^;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{77bc5ebc-ace3-48eb-8e85-e45bc80ac98b}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD Enable : iMover
VAR_INPUT
END_VAR
VAR
END_VAR
VAR_INST
	MsgCreate	: FB_TcMessage;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF LocalVars.State = MV_IDLE THEN

	// Sets an internal flag to advance the state machine
	LocalVars.Enable		:= TRUE;
	
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverEnable,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath);
	MsgCreate.Send(0);

END_IF;

THIS^.SourceInstancePath	:= 'Direct access';

Enable := THIS^;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GroupStop" Id="{19a65925-9b39-4de9-ab16-7733d66c5fd4}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD GroupStop : iMover
VAR_INPUT
END_VAR
VAR
	newCallTime	: LREAL;
END_VAR
VAR_INST
	MsgCreate	: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

IF NOT( Ready ) THEN	// if the mover is not ready & able to accept a GroupHalt Command

	LocalVars.State	:= MV_ERROR;
	ErrorID			:= 19201;

ELSE	// otherwise execute the command
	
	// grab a timestamp of the command
	newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	
//	fbGroupStop.Execute			:= TRUE;
//	fbGroupStop.Deceleration	:= MotionParameters.Deceleration;
//	fbGroupStop.Jerk			:= MotionParameters.Jerk;
	
	memset( ADR( LocalVars.CurrentDestObjective ), 0, SIZEOF( LocalVars.CurrentDestObjective ));
	LocalVars.CurrentMoveType		:= MoverCommandType_enum.MOVETYPE_NONE;
	
END_IF

IF ( newCallTime - LocalVars.lastCallGroupStop ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverGroupStop,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallGroupStop	:= newCallTime;

GroupStop		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Halt" Id="{1f55ad78-11ad-492d-9f7a-e48ae6feda84}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD Halt : iMover
VAR_INPUT
END_VAR
VAR
	newCallTime: LREAL;
END_VAR
VAR_INST
	MsgCreate: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT( Ready ) THEN
	
	LocalVars.State	:= MV_ERROR;
	ErrorID			:= 19201;
	
ELSIF LocalVars.fbHaltCA.Busy THEN	

	newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	
	// oddly, MC_HaltCA does not include an option for BufferMode
	// so do nothing
	
ELSE
	
	newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	
	LocalVars.fbHaltCA.Execute		:= TRUE;
	LocalVars.fbHaltCA.Deceleration	:= MotionParameters.Deceleration;
	LocalVars.fbHaltCA.Jerk			:= MotionParameters.Jerk;
	
	LocalVars.fbHaltCA( Axis := AxisReference );
	
END_IF

LocalVars.CurrentMoveType		:= MOVETYPE_NONE;
LocalVars.CurrentDestPosition	:= 1E300;

memset( ADR( LocalVars.CurrentDestObjective), 0, SIZEOF( LocalVars.CurrentDestObjective ));
LocalVars.CurrentDestStation	REF= 0;

IF ( newCallTime - LocalVars.lastCallHalt ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverHalt,0);
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(MotionParameters.Deceleration);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallHalt		:= newCallTIme;

Halt	:= THIS^;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="IsCollisionAvoidanceActive" Id="{44271435-f54e-01be-23aa-f70858e56360}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY IsCollisionAvoidanceActive : bool]]></Declaration>
      <Get Name="Get" Id="{44467e48-1af3-057a-2f30-25c270d1fac3}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsCollisionAvoidanceActive := AxisReference.NcToPlc.StateDword2.Flags.AvoidingCollision;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsErrorMover" Id="{a8369f91-5a27-4242-b41b-14b591fb7d8c}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY IsErrorMover : BOOL]]></Declaration>
      <Get Name="Get" Id="{d06d5039-cf68-42aa-9d67-5d9fa7db312d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsErrorMover := FALSE;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsSyncedToAxis" Id="{f2757d0f-8cc6-01d8-3ce1-c233354ecef8}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY IsSyncedToAxis : BOOL]]></Declaration>
      <Get Name="Get" Id="{1582f1e6-442b-0b9d-21b6-52b967b5912b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[

IsSyncedToAxis		:= LocalVars.fbGearInPosAxisCA[0].InSync OR LocalVars.fbGearInPosAxisCA[1].InSync;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsSyncedToMover" Id="{b02e7e76-e41b-42cd-ad2a-fd14e80d7543}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY IsSyncedToMover : BOOL]]></Declaration>
      <Get Name="Get" Id="{b38e44ed-4371-4ccd-ba7f-e98ea73ca608}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[

IsSyncedToMover		:= LocalVars.fbGearInPosMoverCA[0].InSync OR LocalVars.fbGearInPosMoverCA[1].InSync;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsTrackReady" Id="{cd5c6866-73e3-00ad-2292-5fe936355763}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY IsTrackReady : BOOL]]></Declaration>
      <Get Name="Get" Id="{1b14d83a-1ec1-0d2f-1616-ce7f9ce5cce5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsTrackReady := LocalVars.TrackIsReady;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="LogUserEvent" Id="{2ade5417-e15a-4da8-a731-8eb7341e5999}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD LogUserEvent : iMover
VAR_INPUT
	String1	: STRING;	// First content section of user-event message
	String2 : STRING;	// Second content section of user-event message
	String3 : STRING;	// Third content section of user-event message
END_VAR
VAR
END_VAR
VAR_INST
	MsgCreate: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[


MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.UserEvent, 0 );
MsgCreate.ipArguments.Clear().AddString(String1).AddString(String2).AddString(String3);
MsgCreate.Send(0);

LogUserEvent	:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Property Name="MasterMover" Id="{809c0b0b-ecf0-4af1-b9a6-f6c1668f1e51}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY MasterMover : Reference To Mover]]></Declaration>
      <Get Name="Get" Id="{cf9c37de-0f5d-4ab8-bb6c-0c7a9a276e2e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[

IF THIS^.LocalVars.CurrentMoveType = MOVETYPE_SYNC_MOVER THEN
	MasterMover		REF= LocalVars.MasterMover;
ELSE
	MasterMover		REF= 0;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="MoverIndex" Id="{5f0db44a-da6c-04c8-0f32-7b0868675ffd}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY MoverIndex : UDINT]]></Declaration>
      <Get Name="Get" Id="{e4c3fd72-ffe3-080a-0721-acc48b48f2eb}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[MoverIndex:= LocalVars.MoverIndex;
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{58d236b1-d23f-0f60-1fb7-9e6e4f417f7c}">
        <Declaration><![CDATA[
VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LocalVars.MoverIndex:= MoverIndex;
]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="MoveToPosition" Id="{c28d081f-5f21-4357-8651-768a8cf4ef0e}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD PUBLIC MoveToPosition : iMover
VAR_INPUT
	DestinationPosition		: LREAL;	// position on track for a shuttle to move towards
END_VAR
VAR
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT( Ready ) THEN	// if the mover is not ready & able to accept a moveabs command...
	
	LocalVars.State	:= MV_ERROR;
	ErrorID			:= 19201;

ELSIF (NOT THIS^.ValidateTrack()) THEN
	;	// validate track posts error
	
ELSE	// otherwise let 'er rip
	
	newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	LocalVars.Reissue := FALSE;	// reissue no longer necessary
	
	IF LocalVars.fbMoveAbsCA[0].Busy = FALSE THEN
		
		LocalVars.fbMoveAbsCA[0].Jerk			:= MotionParameters.Jerk;
		LocalVars.fbMoveAbsCA[0].Acceleration	:= MotionParameters.Acceleration;
		LocalVars.fbMoveAbsCA[0].Deceleration	:= MotionParameters.Deceleration;
		LocalVars.fbMoveAbsCA[0].Velocity		:= MotionParameters.Velocity;
		LocalVars.fbMoveAbsCA[0].Direction		:= MotionParameters.Direction;
		LocalVars.fbMoveAbsCA[0].Gap			:= MotionParameters.Gap;
		LocalVars.fbMoveAbsCA[0].Options.DynamicsReferenceSystem	:= CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[0].Options.PositionReferenceSystem	:= CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[0].Options.GapControlMode			:= MotionParameters.GapMode;
		
		LocalVars.fbMoveAbsCA[0].Position		:= DestinationPosition;
		
		LocalVars.fbMoveAbsCA[0].BufferMode	:= mcAborting;
		LocalVars.fbMoveAbsCA[0].Execute		:= TRUE;
		 
		LocalVars.fbMoveAbsCA[0].Execute		:= TRUE;		// execute this block, and...
		LocalVars.fbMoveAbsCA[1].Execute		:= FALSE;		// if necessary, interrupt this one
		
		LocalVars.fbMoveAbsCA[0]( Axis := AxisReference );
		
	ELSIF LocalVars.fbMoveAbsCA[1].Busy = FALSE THEN
		
		LocalVars.fbMoveAbsCA[1].Jerk			:= MotionParameters.Jerk;
		LocalVars.fbMoveAbsCA[1].Acceleration	:= MotionParameters.Acceleration;
		LocalVars.fbMoveAbsCA[1].Deceleration	:= MotionParameters.Deceleration;
		LocalVars.fbMoveAbsCA[1].Velocity		:= MotionParameters.Velocity;
		LocalVars.fbMoveAbsCA[1].Direction	:= MotionParameters.Direction;
		LocalVars.fbMoveAbsCA[1].Gap			:= MotionParameters.Gap;
		LocalVars.fbMoveAbsCA[1].Options.DynamicsReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[1].Options.PositionReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[1].Options.GapControlMode			:= MotionParameters.GapMode;

		
		LocalVars.fbMoveAbsCA[1].Position		:= DestinationPosition;
		
		LocalVars.fbMoveAbsCA[1].BufferMode	:= mcAborting;
		LocalVars.fbMoveAbsCA[1].Execute		:= TRUE;
		
		LocalVars.fbMoveAbsCA[1].Execute		:= TRUE;		// execute this block, and...
		LocalVars.fbMoveAbsCA[0].Execute		:= FALSE;		// if necessary, interrupt this one
		
		LocalVars.fbMoveAbsCA[1]( Axis := AxisReference );
		 
	ELSE
		MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverMoveToPositionOverload,0 );
		MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(DestinationPosition);
		MsgCreate.Send(0);
	END_IF
	
END_IF

LocalVars.CurrentMoveType		:= MOVETYPE_POSITION;
LocalVars.CurrentDestPosition := DestinationPosition;

memset( ADR( LocalVars.CurrentDestObjective ), 0, SIZEOF( LocalVars.CurrentDestObjective ));
LocalVars.CurrentDestStation	REF= 0;

IF ( newCallTime - LocalVars.lastCallMovePos ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverMoveToPosition,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(DestinationPosition);
	MsgCreate.Send(0);
END_IF;

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallMovePos		:= newCallTime;

MoveToPosition		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveToStation" Id="{73370b80-491c-4017-a420-f08c462d830e}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD MoveToStation : iMover
VAR_INPUT
	DestinationStation	: REFERENCE TO Station;	
END_VAR
VAR
	newCallTime			: LREAL;
END_VAR
VAR_INST
	MsgCreate			: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT( Ready ) AND NOT(__ISVALIDREF( DestinationStation )) THEN	// if the mover is not ready & able to accept a moveabs command...
	
	LocalVars.State	:= MV_ERROR;
	ErrorID			:= 19201;

ELSIF (NOT THIS^.ValidateTrack()) THEN
	;	// validate track posts error

ELSE	// otherwise let 'er rip
	
	newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	LocalVars.Reissue := FALSE;	// reissue no longer necessary
	
	IF LocalVars.fbMoveAbsCA[0].Busy = FALSE THEN
		
		LocalVars.fbMoveAbsCA[0].Jerk			:= MotionParameters.Jerk;
		LocalVars.fbMoveAbsCA[0].Acceleration	:= MotionParameters.Acceleration;
		LocalVars.fbMoveAbsCA[0].Deceleration	:= MotionParameters.Deceleration;
		LocalVars.fbMoveAbsCA[0].Velocity		:= MotionParameters.Velocity;
		LocalVars.fbMoveAbsCA[0].Direction	:= MotionParameters.Direction;
		LocalVars.fbMoveAbsCA[0].Gap			:= MotionParameters.Gap;
		LocalVars.fbMoveAbsCA[0].Options.DynamicsReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[0].Options.PositionReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[0].Options.GapControlMode			:= MotionParameters.GapMode;
		
		LocalVars.fbMoveAbsCA[0].Position		:= DestinationStation.internalPosition;
		
		LocalVars.fbMoveAbsCA[0].BufferMode	:= mcAborting;
		LocalVars.fbMoveAbsCA[0].Execute		:= TRUE;
		 
		LocalVars.fbMoveAbsCA[0].Execute		:= TRUE;		// execute this block, and...
		LocalVars.fbMoveAbsCA[1].Execute		:= FALSE;		// if necessary, interrupt this one
		
		LocalVars.fbMoveAbsCA[0]( Axis := AxisReference );
		
	ELSIF LocalVars.fbMoveAbsCA[1].Busy = FALSE THEN
		
		LocalVars.fbMoveAbsCA[1].Jerk			:= MotionParameters.Jerk;
		LocalVars.fbMoveAbsCA[1].Acceleration	:= MotionParameters.Acceleration;
		LocalVars.fbMoveAbsCA[1].Deceleration	:= MotionParameters.Deceleration;
		LocalVars.fbMoveAbsCA[1].Velocity		:= MotionParameters.Velocity;
		LocalVars.fbMoveAbsCA[1].Direction	:= MotionParameters.Direction;
		LocalVars.fbMoveAbsCA[1].Gap			:= MotionParameters.Gap;
		LocalVars.fbMoveAbsCA[1].Options.DynamicsReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[1].Options.PositionReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveAbsCA[1].Options.GapControlMode			:= MotionParameters.GapMode;
		
		LocalVars.fbMoveAbsCA[1].Position		:= DestinationStation.internalPosition;
		
		LocalVars.fbMoveAbsCA[1].BufferMode	:= mcAborting;
		LocalVars.fbMoveAbsCA[1].Execute		:= TRUE;
		
		LocalVars.fbMoveAbsCA[1].Execute		:= TRUE;		// execute this block, and...
		LocalVars.fbMoveAbsCA[0].Execute		:= FALSE;		// if necessary, interrupt this one

		LocalVars.fbMoveAbsCA[1]( Axis := AxisReference );	

	ELSE
		MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverMoveToStationOverload,0 );
		MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddString(DestinationStation.InstancePath);
		MsgCreate.Send(0);
		
	END_IF
	
	// Set the current destination object to the instance path of the objective, or 0 if unassigned
	LocalVars.CurrentDestPosition		:= DestinationStation.Position;
	LocalVars.CurrentDestObjective	:= SEL( __ISVALIDREF( DestinationStation ), '', DestinationStation.InstancePath );
	LocalVars.CurrentDestStation		REF= DestinationStation;
	LocalVars.CurrentMoveType			:= MOVETYPE_STATION;
	
	// Register this mover with the station, so the station knows this mover is incoming
	DestinationStation.RegisterMover( THIS^ );
	
END_IF

IF ( newCallTime - LocalVars.lastCallMoveSta ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverMoveToStation,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddString(DestinationStation.InstancePath);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallMoveSta		:= newCallTime;

MoveToStation		:= THIS^;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveVelocity" Id="{b843a8f8-3644-434c-aaf5-7e88053f31b1}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD MoveVelocity : iMover
VAR_INPUT
	DesiredVelocity : LREAL;		//The velocity to be commanded [mm/s]
END_VAR
VAR
	negativeCommand	: BOOL;
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR
VAR CONSTANT
	RelDistance: LREAL := 1e10;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT ( ready ) THEN
	
	LocalVars.State	:= MV_ERROR;
	ErrorID			:= 19201;

ELSIF (NOT THIS^.ValidateTrack()) THEN
	;	// validate track posts error

ELSE
	
	newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	LocalVars.Reissue := FALSE;	// reissue no longer necessary
	
	negativeCommand					:= SEL( DesiredVelocity < 0, FALSE, TRUE );
	MotionParameters.Velocity		:= ABS( DesiredVelocity );
	
	IF LocalVars.fbMoveRelCA[0].Busy = FALSE THEN
		
		LocalVars.fbMoveRelCA[0].Jerk			:= MotionParameters.Jerk;
		
		LocalVars.fbMoveRelCA[0].Acceleration	:= MotionParameters.Acceleration;
		LocalVars.fbMoveRelCA[0].Deceleration	:= MotionParameters.Deceleration;
		LocalVars.fbMoveRelCA[0].Velocity		:= MotionParameters.Velocity;
		LocalVars.fbMoveRelCA[0].Options.DynamicsReferenceSystem	:= CurrentTrack^.OTCID;
		LocalVars.fbMoveRelCA[0].Options.PositionReferenceSystem	:= CurrentTrack^.OTCID;
		LocalVars.fbMoveRelCA[0].Options.GapControlMode			:= MotionParameters.GapMode;
		
		LocalVars.fbMoveRelCA[0].Distance		:= SEL( negativeCommand, RelDistance, -RelDistance );
		LocalVars.fbMoveRelCA[0].Gap			:= MotionParameters.Gap;
		      
		LocalVars.fbMoveRelCA[0].BufferMode	:= mcAborting;
		      
		LocalVars.fbMoveRelCA[0].Execute		:= TRUE;		// execute this block, and...
		LocalVars.fbMoveRelCA[1].Execute		:= FALSE;		// if necessary, interrupt this one
		
		LocalVars.fbMoveRelCA[0]( Axis := AxisReference );
		
	ELSIF LocalVars.fbMoveRelCA[1].Busy = FALSE THEN
		
		LocalVars.fbMoveRelCA[1].Jerk			:= MotionParameters.Jerk;
		
		LocalVars.fbMoveRelCA[1].Acceleration	:= MotionParameters.Acceleration;
		LocalVars.fbMoveRelCA[1].Deceleration	:= MotionParameters.Deceleration;
		LocalVars.fbMoveRelCA[1].Velocity		:= MotionParameters.Velocity;
		LocalVars.fbMoveRelCA[1].Options.DynamicsReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveRelCA[1].Options.PositionReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbMoveRelCA[1].Options.GapControlMode			:= MotionParameters.GapMode;
		LocalVars.fbMoveRelCA[1].Gap			:= MotionParameters.Gap;
		LocalVars.fbMoveRelCA[1].Distance		:= SEL( negativeCommand, RelDistance, -RelDistance );
		      
		LocalVars.fbMoveRelCA[1].BufferMode	:= mcAborting;
		      
		LocalVars.fbMoveRelCA[1].Execute		:= TRUE;		// execute this block, and...
		LocalVars.fbMoveRelCA[0].Execute		:= FALSE;		// if necessary, interrupt this one

		LocalVars.fbMoveRelCA[1]( Axis := AxisReference );
	ELSE
		MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverMoveVelocityOverload,0 );
		MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(DesiredVelocity);
		MsgCreate.Send(0);
	END_IF

END_IF

LocalVars.fbMoveRelCA[0] ( Axis := AxisReference );
LocalVars.fbMoveRelCA[1] ( Axis := AxisReference );


LocalVars.CurrentMoveType		:= MOVETYPE_VELOCITY;
LocalVars.CurrentDestPosition := 1E300;

memset( ADR( LocalVars.CurrentDestObjective ), 0, SIZEOF( LocalVars.CurrentDestObjective ));
LocalVars.CurrentDestStation	REF= 0;

IF ( newCallTime - LocalVars.lastCallMoveVel ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverMoveVelocity,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(DesiredVelocity);
	MsgCreate.Send(0);
END_IF;

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallMoveVel		:= newCallTime;

MoveVelocity		:= THIS^;

]]></ST>
      </Implementation>
    </Method>
    <Property Name="NextMover" Id="{852f964d-8625-0223-189c-c4fa1a4b313d}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY NextMover : Reference To Mover]]></Declaration>
      <Get Name="Get" Id="{af159a86-85bb-082d-3056-88b1545f1281}">
        <Declaration><![CDATA[VAR
	i						: UINT;
	currentDifference		: LREAL;
	minimumDifference		: LREAL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[

minimumDifference		:= 1E300;
FOR i := 1 TO Param.MAX_MOVERS DO	
	IF Mediator.MoverArray[i] <> 0 AND_THEN Mediator.MoverArray[i] <> THIS THEN		// pointer validity
		currentDifference			:= Mediator.MoverArray[i]^.AxisReference.NcToPlc.SetPos - THIS^.AxisReference.NcToPlc.SetPos;
						
		// remain within the same lap
		IF currentDifference < 0 THEN
			currentDifference 		:= currentDifference + LocalVars.Track^.Length;
		END_IF
	
		IF currentDifference < minimumDifference THEN
			NextMover				REF= Mediator.MoverArray[i]^;
			minimumDifference		:= currentDifference;
		END_IF
	END_IF	
END_FOR]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Payload" Id="{5caf95a6-ad6c-448d-8947-8c8c07ab0a26}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY Payload : MoverPayload_typ]]></Declaration>
      <Get Name="Get" Id="{8a73f5fd-2b02-4094-9725-10c35f9f9334}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[

Payload	:= LocalVars.Payload;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{6f8bbb61-047b-455a-a948-12da14d2f890}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[

LocalVars.Payload	:= Payload;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="PreviousMover" Id="{831a5835-1520-04bd-1df4-b0219fd1d25b}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY PreviousMover : REFERENCE TO Mover]]></Declaration>
      <Get Name="Get" Id="{a5a30b40-f29c-03c3-3ba4-ac79951c1881}">
        <Declaration><![CDATA[VAR
	
	i					: UINT;
	currentDifference	: LREAL;
	minimumDifference	: LREAL;

END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[

minimumDifference		:= 1E300;
FOR i := 1 TO Param.MAX_MOVERS DO
	IF Mediator.MoverArray[i] <> 0 AND_THEN Mediator.MoverArray[i] <> THIS THEN		// pointer validity
		currentDifference			:= THIS^.AxisReference.NcToPlc.SetPos - Mediator.MoverArray[i]^.AxisReference.NcToPlc.SetPos;
		
		// remain within the same lap
		IF currentDifference < 0 THEN
			currentDifference		:= currentDifference + LocalVars.Track^.Length;
		END_IF
		
		IF currentDifference < minimumDifference THEN
			PreviousMover			REF= Mediator.MoverArray[i]^;
			minimumDifference		:= currentDifference;
		END_IF
	END_IF
END_FOR]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="ReissueCommand" Id="{195ecbe2-3d92-4d60-b9b5-7e1a3292ea5b}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD ReissueCommand : iMover
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// set flag for use in .Cyclic()
LocalVars.Reissue := TRUE;


ReissueCommand		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{3f4121c9-dc27-027e-00e6-8dfd8a6bb208}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD Reset : iMover
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// call the reset command on the mover immediately
LocalVars.fbReset(Axis := AxisReference, Execute := TRUE);
LocalVars.fbReset(Axis := AxisReference, Execute := FALSE);

// clear the mover's error statuses
Error	:= FALSE;
ErrorID	:= 0;
ErrorOrigin := '';

// if the axis is still in error, pass thru the axis error
// errors generated by FBs are point-in-time errors and will regenerate if the same fb is called again
IF AxisReference.Status.Error THEN
	ErrorID					:= AxisReference.Status.ErrorID;
	ErrorOrigin				:= Concat(InstancePath, ': General NC Error immediately after .Reset()');
	LocalVars.State			:= MV_ERROR;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetAcceleration" Id="{6c3e67ff-faff-4c11-8768-1de83c7995e4}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetAcceleration : iMover
VAR_INPUT
	Acceleration	: LREAL;
END_VAR
VAR
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;

MotionParameters.Acceleration		:= LIMIT( 0, Acceleration, 1E300 );	// upper limit is capped by the axis object parameters

THIS^.ReissueCommand();

IF ( newCallTime - LocalVars.lastCallSetAcc ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSetAcceleration,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(Acceleration);
	MsgCreate.Send(0);
END_IF;

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSetAcc		:= newCallTime;

SetAcceleration		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDeceleration" Id="{05a8542e-78cf-4f19-864b-98da64430703}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetDeceleration : iMover
VAR_INPUT
	Deceleration	: LREAL;
END_VAR
VAR
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;

MotionParameters.Deceleration	:= LIMIT( 0, Deceleration, 1E300 ); // upper limit is capped by the axis parameters

THIS^.ReissueCommand();

IF ( newCallTime - LocalVars.lastCallSetDec ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSetDeceleration,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(Deceleration);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSetDec		:= newCallTime;

SetDeceleration		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetDirection" Id="{e0c3c5b2-5259-4ab4-9ff7-1ecaf9015b31}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetDirection : iMover
VAR_INPUT
	Direction		: Tc3_Mc3Definitions.MC_Direction;
END_VAR
VAR
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;

MotionParameters.Direction		:= Direction;

THIS^.ReissueCommand();

IF ( newCallTime - LocalVars.lastCallSetDir ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSetDirection,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddInt(TO_INT(Direction));
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSetDir		:= newCallTime;

SetDirection		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetGap" Id="{b046818d-e6b7-0786-00d1-dec2154637f1}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetGap : iMover
VAR_INPUT
	Gap	: LREAL;
END_VAR
VAR
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;

MotionParameters.Gap		:= LIMIT( 0, Gap, 1E300 );	// upper limit is capped by the axis object parameters

THIS^.ReissueCommand();

IF ( newCallTime - LocalVars.lastCallSetGap ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSetGap,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(Gap);
	MsgCreate.Send(0);
END_IF;

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSetGap		:= newCallTime;

SetGap		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetGapMode" Id="{a4e6725e-191a-0c31-2393-58563c314975}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetGapMode : iMover
VAR_INPUT
	Mode	: MC_GAP_CONTROL_MODE;
END_VAR
VAR
	newCallTime		: LREAL;
	ModeString		: STRING;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;

MotionParameters.GapMode		:= Mode;	// update gap mode

THIS^.ReissueCommand();

IF ( newCallTime - LocalVars.lastCallSetGap ) > 1 THEN
	// user-friendly string for mode
	CASE Mode OF
		MC_GAP_CONTROL_MODE.mcGapControlModeGroupDefault:
			ModeString := 'Group Default';
		MC_GAP_CONTROL_MODE.mcGapControlModeStandard:
			ModeString := 'Standard';
		MC_GAP_CONTROL_MODE.mcGapControlModeFast:
			ModeString := 'Fast';
		MC_GAP_CONTROL_MODE.mcGapControlModeNone:
			ModeString := 'None';
	END_CASE;
	
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSetGapMode,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddString(ModeString);
	MsgCreate.Send(0);
END_IF;

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSetGap		:= newCallTime;

SetGapMode		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetJerk" Id="{de57e13f-25de-42a4-aec6-c6dc8b78d964}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetJerk : iMover
VAR_INPUT
	Jerk		: LREAL;
END_VAR
VAR
	newCallTime	: LREAL;
END_VAR
VAR_INST
	MsgCreate	: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;

MotionParameters.Jerk		:= LIMIT( 0, Jerk, 1E300 ); // upper limit is capped by the axis parameters

THIS^.ReissueCommand();

IF ( newCallTime - LocalVars.lastCallSetJerk ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSetJerk,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(Jerk);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSetJerk		:= newCallTIme;

SetJerk		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetVelocity" Id="{530483ab-165f-437b-baf5-2db027b7f044}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetVelocity : iMover
VAR_INPUT
	Velocity		: LREAL;		// Updates Mover's internal velocity parameter. Takes effect immediately. [mm/s]
END_VAR
VAR
	LogEvent		: INT;
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;

MotionParameters.Velocity	:= LIMIT( 0, Velocity, 1E300 ); // upper limit is capped by the axis parameters 

THIS^.ReissueCommand();

IF ( newCallTime - LocalVars.lastCallSetVel ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSetVelocity,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddLReal(Velocity);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSetVel	:= newCallTime;

SetVelocity		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SyncToAxis" Id="{6776bdec-2c5f-03ab-27c8-402842cfde2e}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SyncToAxis : iMover
VAR_INPUT
	
	MasterAxis		: REFERENCE TO AXIS_REF;
	MasterSyncPos	: LREAL;				// Master sync position (nonmodulo), where the input axis will be located when first synchronized
	SlaveSyncPos	: LREAL;				// Mover sync position, where the mover will be located when first synchronized
	SyncStrategy	: MC_SYNC_STRATEGY;		// Direction input
	
END_VAR
VAR
	newCallTime		: LREAL;
END_VAR
VAR_INST
	MsgCreate		: FB_TcMessage;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[

IF NOT( Ready ) THEN
	
	LocalVars.State		:= MV_ERROR;
	ErrorID				:= 19201;
	
ELSE
	
	newCallTime			:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	LocalVars.Reissue := FALSE;	// reissue no longer necessary
	
	LocalVars.MasterAxis		REF= MasterAxis;
	
	IF LocalVars.fbGearInPosAxisCA[0].Busy = FALSE THEN
		
		LocalVars.fbGearInPosAxisCA[0].Execute			:= TRUE;
		
		LocalVars.fbGearInPosAxisCA[0].MasterSyncPosition	:= MasterSyncPos;	// This needs to be nonmodulo
		LocalVars.fbGearInPosAxisCA[0].SlaveSyncPosition	:= SlaveSyncPos;
		
		LocalVars.fbGearInPosAxisCA[0].SyncStrategy		:= SyncStrategy;
		
		LocalVars.fbGearInPosAxisCA[0].Options.DynamicsReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbGearInPosAxisCA[0].Options.SlaveSyncPositionReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbGearInPosAxisCA[0].Options.GapControlMode := MotionParameters.GapMode;
		LocalVars.fbGearInPosAxisCA[0].Gap := MotionParameters.Gap;

		IF MotionParameters.Direction = mcDirectionPositive THEN
			LocalVars.fbGearInPosAxisCA[0].SyncMode		:= mcSyncModePositive;
		ELSIF MotionParameters.Direction = mcDirectionNegative THEN
			LocalVars.fbGearInPosAxisCA[0].SyncMode		:= mcSyncModeNegative;
		ELSE // mcDirectionNonModulo or mcDirectionShortestWay
			LocalVars.fbGearInPosAxisCA[0].SyncMode		:= mcSyncModeNonModulo;
		END_IF
		
		LocalVars.fbGearInPosAxisCA[0].Velocity			:= MotionParameters.Velocity;
		LocalVars.fbGearInPosAxisCA[0].Acceleration		:= MotionParameters.Acceleration;
		LocalVars.fbGearInPosAxisCA[0].Deceleration		:= MotionParameters.Deceleration;
		LocalVars.fbGearInPosAxisCA[0].Jerk				:= MotionParameters.Jerk;
		
		LocalVars.fbGearInPosAxisCA[0].BufferMode			:= Tc3_Mc3Definitions.MC_BUFFER_MODE.mcAborting;
		
		LocalVars.fbGearInPosAxisCA[0]( Master := MasterAxis, Slave := THIS^.AxisReference );		
		
	ELSIF LocalVars.fbGearInPosAxisCA[1].Busy = FALSE THEN
		
		LocalVars.fbGearInPosAxisCA[1].Execute			:= TRUE;
		
		LocalVars.fbGearInPosAxisCA[1].MasterSyncPosition	:= MasterSyncPos;	// This needs to be nonmodulo
		LocalVars.fbGearInPosAxisCA[1].SlaveSyncPosition	:= SlaveSyncPos;
		
		LocalVars.fbGearInPosAxisCA[1].SyncStrategy		:= SyncStrategy;
		
		LocalVars.fbGearInPosAxisCA[1].Options.DynamicsReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbGearInPosAxisCA[1].Options.SlaveSyncPositionReferenceSystem := CurrentTrack^.OTCID;
		LocalVars.fbGearInPosAxisCA[1].Options.GapControlMode := MotionParameters.GapMode;
		LocalVars.fbGearInPosAxisCA[1].Gap := MotionParameters.Gap;
		
		IF MotionParameters.Direction = mcDirectionPositive THEN
			LocalVars.fbGearInPosAxisCA[1].SyncMode		:= mcSyncModePositive;
		ELSIF MotionParameters.Direction = mcDirectionNegative THEN
			LocalVars.fbGearInPosAxisCA[1].SyncMode		:= mcSyncModeNegative;				
		ELSE // mcDirectionNonModulo or mcDirectionShortestWay
			LocalVars.fbGearInPosAxisCA[1].SyncMode		:= mcSyncModeNonModulo;
		END_IF
		
		LocalVars.fbGearInPosAxisCA[1].Velocity			:= MotionParameters.Velocity;
		LocalVars.fbGearInPosAxisCA[1].Acceleration		:= MotionParameters.Acceleration;
		LocalVars.fbGearInPosAxisCA[1].Deceleration		:= MotionParameters.Deceleration;
		LocalVars.fbGearInPosAxisCA[1].Jerk				:= MotionParameters.Jerk;
		
		LocalVars.fbGearInPosAxisCA[1].BufferMode			:= Tc3_Mc3Definitions.MC_BUFFER_MODE.mcAborting;
		
		LocalVars.fbGearInPosAxisCA[1]( Master := MasterAxis, Slave := THIS^.AxisReference );

	ELSE
		MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSyncToAxisOverload, 0 );
		MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath);
		MsgCreate.Send(0);
	END_IF
	
END_IF

LocalVars.CurrentMoveType			:= MOVETYPE_SYNC_AXIS;
LocalVars.CurrentDestPosition		:= 1E300;

memset( ADR( LocalVars.CurrentDestObjective ), 0, SIZEOF( LocalVars.CurrentDestObjective ));
LocalVars.CurrentDestStation		REF= 0;

IF ( newCallTime - LocalVars.lastCallSync ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSyncToAxis, 0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath		:= 'Direct access';

LocalVars.lastCallSync	:= newCallTime;

SyncToAxis		:= THIS^;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SyncToMover" Id="{c1dddc96-f9c0-4f4e-b1ac-4bb8d23d72f1}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SyncToMover : iMover
VAR_INPUT
	MasterMover			: REFERENCE TO Mover;	// Synchronization master mover, whose position to follow. Further motion commands break the pairing
	Gap					: LREAL;				// Gap distance to lead mover. Positive values indicate following, negative values indicate leading
END_VAR
VAR
	newCallTime			: LREAL;
END_VAR
VAR_INST
	MsgCreate			: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT( Ready ) THEN

	LocalVars.State	:= MV_ERROR;
	ErrorID			:= 19201;
	
ELSE	// let 'er rip
	
	newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
	LocalVars.Reissue := FALSE;	// reissue no longer necessary

	LocalVars.MasterMover		REF= MasterMover;
	LocalVars.Gap				:= Gap;
		
	IF LocalVars.fbGearInPosMoverCA[0].Busy = FALSE THEN
		
		LocalVars.fbGearInPosMoverCA[0].Execute				:= TRUE;
		LocalVars.fbGearInPosMoverCA[1].Execute				:= FALSE;
		
		LocalVars.fbGearInPosMoverCA[0].MasterSyncPosition				:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos;
		
		// If the slave setpos is less than the master...
		IF THIS^.AxisReference.NcToPlc.SetPos <= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos THEN
			IF Gap > 0 THEN		// ... And the Gap is Positive
				LocalVars.fbGearInPosMoverCA[0].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos - Gap;		
			ELSE				// ... And the Gap is Negative
				LocalVars.fbGearInPosMoverCA[0].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos - LocalVars.Track^.Length - Gap;
			END_IF
		
		// If the slave setpos is greater than the master...
		ELSE (* THIS.AxisReference.NcToPlc.SetPos > LocalVars.MasterMover.AxisReference.NcToPlc.SetPos  *)
			IF Gap > 0 THEN		// ... And the Gap is Positive
				LocalVars.fbGearInPosMoverCA[0].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos + LocalVars.Track^.Length - Gap;
			ELSE			// ... And the Gap is Negative
				LocalVars.fbGearInPosMoverCA[0].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos - Gap;				
			END_IF
		
		END_IF
		
		LocalVars.fbGearInPosMoverCA[0].SyncStrategy					:= mcSyncStrategyEarly;
		
		LocalVars.fbGearInPosMoverCA[0].Options.DynamicsReferenceSystem				:= CurrentTrack^.OTCID;
		LocalVars.fbGearInPosMoverCA[0].Options.SlaveSyncPositionReferenceSystem	:= CurrentTrack^.OTCID;
		LocalVars.fbGearInPosMoverCA[0].Options.GapControlMode						:= MotionParameters.GapMode;
		LocalVars.fbGearInPosMoverCA[0].Gap											:= MotionParameters.Gap;
				
		LocalVars.fbGearInPosMoverCA[0].Velocity				:= MotionParameters.Velocity;
		LocalVars.fbGearInPosMoverCA[0].Acceleration			:= MotionParameters.Acceleration;
		LocalVars.fbGearInPosMoverCA[0].Deceleration			:= MotionParameters.Deceleration;
		LocalVars.fbGearInPosMoverCA[0].Jerk					:= MotionParameters.Jerk;
		
		LocalVars.fbGearInPosMoverCA[0].BufferMode				:= Tc3_Mc3Definitions.MC_BUFFER_MODE.mcAborting;
		
		LocalVars.fbGearInPosMoverCA[0]( Master := LocalVars.MasterMover.AxisReference, Slave := THIS^.AxisReference );
		
	ELSIF LocalVars.fbGearInPosMoverCA[1].Busy = FALSE THEN
		
		LocalVars.fbGearInPosMoverCA[1].Execute				:= TRUE;
		LocalVars.fbGearInPosMoverCA[0].Execute				:= FALSE;
		
		LocalVars.fbGearInPosMoverCA[1].MasterSyncPosition				:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos;
		
		// If the slave setpos is less than the master...
		IF THIS^.AxisReference.NcToPlc.SetPos <= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos THEN
			IF Gap > 0 THEN		// ... And the Gap is Positive
				LocalVars.fbGearInPosMoverCA[1].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos - Gap;		
			ELSE				// ... And the Gap is Negative
				LocalVars.fbGearInPosMoverCA[1].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos - LocalVars.Track^.Length - Gap;
			END_IF
		
		// If the slave setpos is greater than the master...
		ELSE (* THIS.AxisReference.NcToPlc.SetPos > LocalVars.MasterMover.AxisReference.NcToPlc.SetPos  *)
			IF Gap > 0 THEN		// ... And the Gap is Positive
				LocalVars.fbGearInPosMoverCA[1].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos + LocalVars.Track^.Length - Gap;
			ELSE			// ... And the Gap is Negative
				LocalVars.fbGearInPosMoverCA[1].SlaveSyncPosition		:= LocalVars.MasterMover.AxisReference.NcToPlc.SetPos - Gap;				
			END_IF
		
		END_IF
		
		LocalVars.fbGearInPosMoverCA[1].SyncStrategy					:= mcSyncStrategyEarly;		
				
		LocalVars.fbGearInPosMoverCA[1].Options.DynamicsReferenceSystem				:= CurrentTrack^.OTCID;
		LocalVars.fbGearInPosMoverCA[1].Options.SlaveSyncPositionReferenceSystem	:= CurrentTrack^.OTCID;
		LocalVars.fbGearInPosMoverCA[1].Options.GapControlMode						:= MotionParameters.GapMode;
		LocalVars.fbGearInPosMoverCA[1].Gap											:= MotionParameters.Gap;
				
		LocalVars.fbGearInPosMoverCA[1].Velocity				:= MotionParameters.Velocity;
		LocalVars.fbGearInPosMoverCA[1].Acceleration			:= MotionParameters.Acceleration;
		LocalVars.fbGearInPosMoverCA[1].Deceleration			:= MotionParameters.Deceleration;
		LocalVars.fbGearInPosMoverCA[1].Jerk					:= MotionParameters.Jerk;
		
		LocalVars.fbGearInPosMoverCA[1].BufferMode				:= Tc3_Mc3Definitions.MC_BUFFER_MODE.mcAborting;
		
		LocalVars.fbGearInPosMoverCA[1]( Master := LocalVars.MasterMover.AxisReference, Slave := THIS^.AxisReference );
		
	ELSE
		MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSyncToMoverOverload,0 );
		MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddString(SourceInstancePath).AddLReal(Gap);
		MsgCreate.Send(0);
		
	END_IF

END_IF;

LocalVars.CurrentMoveType			:= MOVETYPE_SYNC_MOVER;
LocalVars.CurrentDestPosition		:= 1E300;

memset( ADR( LocalVars.CurrentDestObjective ), 0, SIZEOF( LocalVars.CurrentDestObjective ));
LocalVars.CurrentDestStation	REF= 0;

IF ( newCallTime - LocalVars.lastCallSync ) > 1 THEN
	MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.MoverSyncToMover,0 );
	MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath).AddString(SourceInstancePath).AddLReal(Gap);
	MsgCreate.Send(0);
END_IF

THIS^.SourceInstancePath	:= 'Direct access';

LocalVars.lastCallSync		:= newCallTime;


SyncToMover		:= THIS^;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="UnregisterFromAll" Id="{f143e1ea-77ff-0f0f-21c3-e86b5d1cb377}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD UnregisterFromAll : BOOL
VAR_INPUT
	i		: ULINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 0 TO Param.NUM_MOVERLISTS-1 DO
	Mediator.MoverListArray[i]^.UnregisterMover( THIS^ );
END_FOR

FOR i := 0 TO Param.NUM_POSITIONTRIGGERS-1 DO
	Mediator.PositionTriggerArray[i]^.UnregisterMover( THIS^ );
END_FOR

FOR i := 0 TO Param.NUM_STATIONS-1 DO
	Mediator.StationArray[i]^.UnregisterMover( THIS^ );
END_FOR

FOR i := 0 TO Param.NUM_ZONES-1 DO
	Mediator.ZoneArray[i]^.UnregisterMover( THIS^ );
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="ValidateTrack" Id="{230f15af-f744-0e9b-0384-784f5f4f41dd}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD ValidateTrack : BOOL
VAR_INPUT
END_VAR
VAR
	newCallTime: LREAL;
END_VAR
VAR_INST
	MsgCreate			: FB_TcMessage;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// confirms that a valid track is selected and return true
// otherwise throws error and returns false, to be handled by higher-level code
IF LocalVars.TrackIsReady THEN
	ValidateTrack := TRUE;
ELSE
	ValidateTrack := FALSE;
		newCallTime		:= ULINT_TO_LREAL(F_GetSystemTime())/1E7;
		
	IF ( newCallTime - LocalVars.lastCallValidateTrack ) > 1 THEN
		MsgCreate.CreateEx( TC_EVENTS.XtsBaseEventClass.ValidateTrackError,0 );
		MsgCreate.ipArguments.Clear().AddString(THIS^.InstancePath).AddString(THIS^.SourceInstancePath);
		MsgCreate.Send(0);
	END_IF	
END_IF

LocalVars.lastCallValidateTrack		:= newCallTime;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="Mover">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.ActivateTrack">
      <LineId Id="3" Count="25" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.CurrentDestinationPosition.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.CurrentDestinationTrack.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.CurrentMoveType.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.CurrentObjective.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.CurrentTrack.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.Cyclic">
      <LineId Id="3" Count="508" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.Disable">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.Enable">
      <LineId Id="3" Count="14" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.GroupStop">
      <LineId Id="3" Count="30" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.Halt">
      <LineId Id="3" Count="41" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.IsCollisionAvoidanceActive.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.IsErrorMover.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.IsSyncedToAxis.Get">
      <LineId Id="3" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.IsSyncedToMover.Get">
      <LineId Id="3" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.IsTrackReady.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.LogUserEvent">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.MasterMover.Get">
      <LineId Id="3" Count="5" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.MoverIndex.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.MoverIndex.Set">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.MoveToPosition">
      <LineId Id="3" Count="82" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.MoveToStation">
      <LineId Id="3" Count="86" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.MoveVelocity">
      <LineId Id="3" Count="85" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.NextMover.Get">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.Payload.Get">
      <LineId Id="3" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.Payload.Set">
      <LineId Id="3" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.PreviousMover.Get">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.ReissueCommand">
      <LineId Id="3" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.Reset">
      <LineId Id="3" Count="14" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SetAcceleration">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SetDeceleration">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SetDirection">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SetGap">
      <LineId Id="3" Count="15" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SetGapMode">
      <LineId Id="3" Count="27" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SetJerk">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SetVelocity">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SyncToAxis">
      <LineId Id="3" Count="17" />
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="29" />
      <LineId Id="57" Count="0" />
      <LineId Id="59" Count="50" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.SyncToMover">
      <LineId Id="3" Count="16" />
      <LineId Id="23" Count="39" />
      <LineId Id="66" Count="65" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.UnregisterFromAll">
      <LineId Id="3" Count="14" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="Mover.ValidateTrack">
      <LineId Id="3" Count="14" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>