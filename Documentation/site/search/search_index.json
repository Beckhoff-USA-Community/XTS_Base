{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"","title":"Home"},{"location":"CodeReference/Diagnostics.html","text":"Under Construction","title":"Basics"},{"location":"CodeReference/Mover.html","text":"Mover Object The Mover function block is the heart of the solution. It contains essential functionality, including: Basic administrative commands like enabling & resetting Easily commanding movements to absolute positions or stations Reading out current move status information like position, velocity, etc. Updating motion parameters during operation Setup & Execution It is recommended, but not required, to declare Movers as an array. 1 2 3 4 // Instance declaration Mover : ARRAY [ 0. . GVL . NUM_MOVERS - 1 ] OF Mover ; ParameterSet : MoverParameters_typ ; Movers contain a Cyclic() method that must be called every cycle. This cyclic method must also be given a Collision Avoidance Group reference as an argument. 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_MOVERS - 1 ] DO Mover [ i ]. Cyclic ( GroupRef ); END_FOR Methods Enable Enable() Carries out steps to prepare the Mover for motion commands. An internal MC_Reset function block is called to reset any errors that may exist on the Axis object. The mover will read M1 Detection Settings configured in the XtsProcessingUnit. If M1 Detection is configured, the Mover will activate this process to find Mover 1. If this is not configured, this step is skipped. An internal MC_Power function block is called to energize the axis object. The mover will automatically add itself to a Collision Avoidance group, and if necessary will also automatically enable this group. The mover will set its Ready output True. 1 Mover [ 1 ]. Enable (); Disable Disable() Disables the mover. Holding Torque will be lost. Method will automatically remove the mover from its Collision Avoidance group. 1 Mover [ 1 ]. Disable (); MoveToPosition MoveToPosition( Destination : LREAL ) Executes an Absolute Move (with Collision Avoidance) to the target location. 1 2 3 4 IF xMoveCommand THEN Mover [ 1 ]. MoveToPosition ( 1200 ); xMoveCommand := FALSE ; END_IF MoveToStation MoveToStation( Destination : Station ) Executes an Absolute Move (with Collision Avoidance) to the location of the target Station, and implicitly calls that Station's RegisterMover method. 1 2 3 4 IF xMoveToHome THEN Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); xMoveToHome := FALSE ; END_IF MoveVelocity MoveVelocity( DesiredVelocity : LREAL ) Executes a Velocity movement (with Collision Avoidance) at the specified Velocity. This command also implicitly updates the Mover's internal Velocity Motion Parameter. 1 2 3 4 IF xMoveVelocity THEN Mover [ 1 ]. MoveVelocity ( 2000 ); xMoveVelocity := FALSE ; END_IF ReissueCommand ReissueCommand() Executes the latest command that was issued to the mover, e.g. a MoveToPosition command. The move is executed with the current internal Motion Parameters of the Mover, so the dynamics of the mover may not exactly match what was initially commanded. However, in cases of MoveToPosition or MoveToStation, the destination will be the same. To determine what type of movement ReissueCommand() will repeat, see Mover properties CurrentMoveType, CurrentObjective, and CurrentDestinationPosition. 1 2 3 4 5 6 7 8 9 10 11 12 // Issue a primary command IF xInitialCommand THEN Mover [ 1 ]. SetVelocity ( 500 ); Mover [ 1 ]. MoveToPosition ( 1000 ); xInitialCommand := FALSE ; // Reissue the primary command, but with a new velocity parameter ELSIF xUpdateCommand THEN Mover [ 1 ]. SetVelocity ( 750 ); Mover [ 1 ]. ReissueCommand (); xUpdateCommand := FALSE ; END_IF SetAcceleration SetAcceleration( DesiredAccel : LREAL ) Updates the Mover's internal Motion Parameter for Acceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandHighAccel THEN Mover [ 1 ]. SetAcceleration ( 2e4 ); // mm/s2 xCommandHighAccel := FALSE ; END_IF SetDeceleration SetDeceleration( DesiredDecel : LREAL ) Updates the Mover's internal Motion Parameter for Deceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandLowDecel THEN Mover [ 1 ]. SetDeceleration ( 1e3 ); // mm/s2 xCommandLowDecel := FALSE ; END_IF SetDirection SetDirection( Direction : Tc3_Mc3Definitions.MC_Direction ); Updates the Mover's internal Motion Parameter for Direction and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately This method should only be used with care, and an understanding that a mover enroute will immediately reverse course and execute a motion command in the opposite direction when this method is called. 1 2 3 4 5 6 // For supported directions, see Infosys IF xReverseDirection THEN Mover [ 1 ]. SetDirection ( mcDirectionPositive ); xReverseDirection := FALSE ; END_IF SetJerk SetJerk( Jerk : LREAL ) Updates the Mover's internal Motion Parameter for Jerk [mm/s3] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xUpdateJerk THEN Mover [ 1 ]. UpdateJerk ( 1e5 ); xUpdateJerk := FALSE ; END_IF SetVelocity SetVelocity( DesiredVelocity : LREAL ) Updates the Mover's internal Motion Parameter for Velocity [mm/s] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandSlowMode THEN Mover [ 1 ]. SetVelocity ( 500 ); // mm/s xCommandSlowMode := FALSE ; END_IF Properties .CurrentMoveType MoverCommandType_enum 1 2 3 4 MOVETYPE_NONE // this mover was just enabled and has no movement history MOVETYPE_POSITION // this mover was most recently issued a MoveToPosition command MOVETYPE_STATION // this mover was most recently issued a MoveToStation command MOVETYPE_VELOCITY // this mover was most recently issued a MoveVelocity command Provides the current (last executed) type of movement command issued to the Mover .CurrentDestinationPosition LREAL Provides the current destination position for the last movement command issued to the Mover. For Station commands, this will be the TrackPosition of the Station. For Velocity commands with no real destination position, the value is set to +/-1E300. .MotionParameters MotionParameters_typ Defines a structure containing the dynamics settings for the Mover. Any new motion commands issued will utilize these values. Note: despite listing this value as a Property here in the documentation, MotionParameters are actually defined as a regular Input to the Mover object. This allows component access to the members of the STRUCT, which is not possible for Properties. .CurrentObjective STRING Provides the current Objective destination for the Mover. Right now this is only valid when the Mover is destined for a Station objective, and provides a string name for that station. .Payload !!! Under Construction !!! At the moment, this property is a placeholder for application specific information regarding the current status of products onboard the mover, and can be modified as needed for your application. Extra Examples Below are simple examples of different operations utilizing the Mover object: 1 2 3 // Mover: ARRAY [0..GVL.NUM_MOVERS] OF Mover Mover [ 1 ]. SetVelocity ( 2500 ); Mover [ 1 ]. MoveToPosition ( 1200 );","title":"Mover"},{"location":"CodeReference/Mover.html#mover-object","text":"The Mover function block is the heart of the solution. It contains essential functionality, including: Basic administrative commands like enabling & resetting Easily commanding movements to absolute positions or stations Reading out current move status information like position, velocity, etc. Updating motion parameters during operation","title":"Mover Object"},{"location":"CodeReference/Mover.html#setup-execution","text":"It is recommended, but not required, to declare Movers as an array. 1 2 3 4 // Instance declaration Mover : ARRAY [ 0. . GVL . NUM_MOVERS - 1 ] OF Mover ; ParameterSet : MoverParameters_typ ; Movers contain a Cyclic() method that must be called every cycle. This cyclic method must also be given a Collision Avoidance Group reference as an argument. 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_MOVERS - 1 ] DO Mover [ i ]. Cyclic ( GroupRef ); END_FOR","title":"Setup &amp; Execution"},{"location":"CodeReference/Mover.html#methods","text":"","title":"Methods"},{"location":"CodeReference/Mover.html#enable","text":"Enable() Carries out steps to prepare the Mover for motion commands. An internal MC_Reset function block is called to reset any errors that may exist on the Axis object. The mover will read M1 Detection Settings configured in the XtsProcessingUnit. If M1 Detection is configured, the Mover will activate this process to find Mover 1. If this is not configured, this step is skipped. An internal MC_Power function block is called to energize the axis object. The mover will automatically add itself to a Collision Avoidance group, and if necessary will also automatically enable this group. The mover will set its Ready output True. 1 Mover [ 1 ]. Enable ();","title":"Enable"},{"location":"CodeReference/Mover.html#disable","text":"Disable() Disables the mover. Holding Torque will be lost. Method will automatically remove the mover from its Collision Avoidance group. 1 Mover [ 1 ]. Disable ();","title":"Disable"},{"location":"CodeReference/Mover.html#movetoposition","text":"MoveToPosition( Destination : LREAL ) Executes an Absolute Move (with Collision Avoidance) to the target location. 1 2 3 4 IF xMoveCommand THEN Mover [ 1 ]. MoveToPosition ( 1200 ); xMoveCommand := FALSE ; END_IF","title":"MoveToPosition"},{"location":"CodeReference/Mover.html#movetostation","text":"MoveToStation( Destination : Station ) Executes an Absolute Move (with Collision Avoidance) to the location of the target Station, and implicitly calls that Station's RegisterMover method. 1 2 3 4 IF xMoveToHome THEN Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); xMoveToHome := FALSE ; END_IF","title":"MoveToStation"},{"location":"CodeReference/Mover.html#movevelocity","text":"MoveVelocity( DesiredVelocity : LREAL ) Executes a Velocity movement (with Collision Avoidance) at the specified Velocity. This command also implicitly updates the Mover's internal Velocity Motion Parameter. 1 2 3 4 IF xMoveVelocity THEN Mover [ 1 ]. MoveVelocity ( 2000 ); xMoveVelocity := FALSE ; END_IF","title":"MoveVelocity"},{"location":"CodeReference/Mover.html#reissuecommand","text":"ReissueCommand() Executes the latest command that was issued to the mover, e.g. a MoveToPosition command. The move is executed with the current internal Motion Parameters of the Mover, so the dynamics of the mover may not exactly match what was initially commanded. However, in cases of MoveToPosition or MoveToStation, the destination will be the same. To determine what type of movement ReissueCommand() will repeat, see Mover properties CurrentMoveType, CurrentObjective, and CurrentDestinationPosition. 1 2 3 4 5 6 7 8 9 10 11 12 // Issue a primary command IF xInitialCommand THEN Mover [ 1 ]. SetVelocity ( 500 ); Mover [ 1 ]. MoveToPosition ( 1000 ); xInitialCommand := FALSE ; // Reissue the primary command, but with a new velocity parameter ELSIF xUpdateCommand THEN Mover [ 1 ]. SetVelocity ( 750 ); Mover [ 1 ]. ReissueCommand (); xUpdateCommand := FALSE ; END_IF","title":"ReissueCommand"},{"location":"CodeReference/Mover.html#setacceleration","text":"SetAcceleration( DesiredAccel : LREAL ) Updates the Mover's internal Motion Parameter for Acceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandHighAccel THEN Mover [ 1 ]. SetAcceleration ( 2e4 ); // mm/s2 xCommandHighAccel := FALSE ; END_IF","title":"SetAcceleration"},{"location":"CodeReference/Mover.html#setdeceleration","text":"SetDeceleration( DesiredDecel : LREAL ) Updates the Mover's internal Motion Parameter for Deceleration [mm/s2] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandLowDecel THEN Mover [ 1 ]. SetDeceleration ( 1e3 ); // mm/s2 xCommandLowDecel := FALSE ; END_IF","title":"SetDeceleration"},{"location":"CodeReference/Mover.html#setdirection","text":"SetDirection( Direction : Tc3_Mc3Definitions.MC_Direction ); Updates the Mover's internal Motion Parameter for Direction and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately This method should only be used with care, and an understanding that a mover enroute will immediately reverse course and execute a motion command in the opposite direction when this method is called. 1 2 3 4 5 6 // For supported directions, see Infosys IF xReverseDirection THEN Mover [ 1 ]. SetDirection ( mcDirectionPositive ); xReverseDirection := FALSE ; END_IF","title":"SetDirection"},{"location":"CodeReference/Mover.html#setjerk","text":"SetJerk( Jerk : LREAL ) Updates the Mover's internal Motion Parameter for Jerk [mm/s3] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xUpdateJerk THEN Mover [ 1 ]. UpdateJerk ( 1e5 ); xUpdateJerk := FALSE ; END_IF","title":"SetJerk"},{"location":"CodeReference/Mover.html#setvelocity","text":"SetVelocity( DesiredVelocity : LREAL ) Updates the Mover's internal Motion Parameter for Velocity [mm/s] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately 1 2 3 4 IF xCommandSlowMode THEN Mover [ 1 ]. SetVelocity ( 500 ); // mm/s xCommandSlowMode := FALSE ; END_IF","title":"SetVelocity"},{"location":"CodeReference/Mover.html#properties","text":"","title":"Properties"},{"location":"CodeReference/Mover.html#currentmovetype","text":"MoverCommandType_enum 1 2 3 4 MOVETYPE_NONE // this mover was just enabled and has no movement history MOVETYPE_POSITION // this mover was most recently issued a MoveToPosition command MOVETYPE_STATION // this mover was most recently issued a MoveToStation command MOVETYPE_VELOCITY // this mover was most recently issued a MoveVelocity command Provides the current (last executed) type of movement command issued to the Mover","title":".CurrentMoveType"},{"location":"CodeReference/Mover.html#currentdestinationposition","text":"LREAL Provides the current destination position for the last movement command issued to the Mover. For Station commands, this will be the TrackPosition of the Station. For Velocity commands with no real destination position, the value is set to +/-1E300.","title":".CurrentDestinationPosition"},{"location":"CodeReference/Mover.html#motionparameters","text":"MotionParameters_typ Defines a structure containing the dynamics settings for the Mover. Any new motion commands issued will utilize these values. Note: despite listing this value as a Property here in the documentation, MotionParameters are actually defined as a regular Input to the Mover object. This allows component access to the members of the STRUCT, which is not possible for Properties.","title":".MotionParameters"},{"location":"CodeReference/Mover.html#currentobjective","text":"STRING Provides the current Objective destination for the Mover. Right now this is only valid when the Mover is destined for a Station objective, and provides a string name for that station.","title":".CurrentObjective"},{"location":"CodeReference/Mover.html#payload","text":"!!! Under Construction !!! At the moment, this property is a placeholder for application specific information regarding the current status of products onboard the mover, and can be modified as needed for your application.","title":".Payload"},{"location":"CodeReference/Mover.html#extra-examples","text":"Below are simple examples of different operations utilizing the Mover object: 1 2 3 // Mover: ARRAY [0..GVL.NUM_MOVERS] OF Mover Mover [ 1 ]. SetVelocity ( 2500 ); Mover [ 1 ]. MoveToPosition ( 1200 );","title":"Extra Examples"},{"location":"CodeReference/MoverList.html","text":"Mover List Object The Mover List object provides a way to group Movers together and issue commands to every Mover in the list. Alternatively, commands can be sent to individual movers within the list based on their geographic proximity to a track position Setup & Execution 1 2 // Declaration MoverListA : MoverList ; 1 2 3 4 5 6 7 8 9 // Usage MoverListA . RegisterMover ( Mover [ 1 ] ); MoverListA . RegisterMover ( Mover [ 2 ] ); MoverListA . RegisterMover ( Mover [ 3 ] ); MoverListA . SetAllVelocity ( 1000 ); MoverListA . MoveAllToStation ( Station [ 4 ] ); MoverListA . UnregisterAll (); Methods GetMoverByLocation GetMoverByLocation( Index : USINT, Position : LREAL, Direction : Tc2_MC2.MC_Direction ) : REFERENCE TO Mover Returns a reference to a singular mover from the Mover List, based on it's geographic location relative to a fixed track position. Index specifies the number of movers that should lie between the selection and the Position input. Therefore Index = 0 would be the closest mover to the input position (in a given direction), Index = 1 would be the second closest, Index = 2 would be the third closest, etc. Position specifies the target around which mover proximity should be considered. Direction specifies the direction around the track from which the movers are indexed. Therefore MC_Positive_Direction will begin returning movers with the most positive absolute position values that are still less than the position input. 1 2 3 4 5 6 7 8 9 10 11 // Select a mover in the MoverList // Which is the first closest mover to position 900 // And which has a position less than 900 // Then sends it to a station MoverListA . GetMoverByLocation ( 0 , 900 , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] ); // Select a mover in the MoverList // Which is the third closest mover to position 2000 // And which has a position greater than 3000 // Then sets its acceleration MoverListA . GetMoverByLocation ( 2 , 3000 , MC_Negative_Direction ). SetAcceleration ( 1E4 ); MoveAllToPosition MoveAllToPosition( DestinationPosition : LREAL ) Issues individual MoveToPosition commands to every mover registered with the list. 1 MoverListA . MoveAllToPosition ( 1200 ); MoveAllToStation MoveAllToStation( DestinationStation: Station ) Issues individual MoveToStation commands to every mover registered with the list. 1 MoverListA . MoveAllToStation ( Station [ 3 ] ); MoveAllVelocity MoveAllVelocity( DesiredVelocity : LREAL ) Issues individual MoveVelocity commands to every mover registered with the list. 1 MoverListA . MoveAllVelocity ( 300 ); SetAllAcceleration SetAllAcceleration( DesiredAcceleration : LREAL ) Sets the acceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllAcceleration ( 1E3 ); SetAllDeceleration SetAllDeceleration( DesiredDeceleration : LREAL ) Sets the deceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDeceleration ( 15000 ); SetAllDirection SetAllDirection( Direction : Tc3_Mc3Definitions.MC_DIRECTION ) Sets the direction motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDirection ( mcDirectionPositive ); SetAllJerk SetAllJerk( DesiredJerk : LREAL ) Sets the jerk motion parameter equal to the input argument for every mover in the list 1 MoverListA.SetAllJerk( 1e5 ); SetAllVelocity SetAllVelocity( DesiredVelocity : LREAL ) Sets the velocity motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllVelocity ( 2000 ); StopAll StopAll() Stops all movers in the list by calling their individual Stop methods 1 MoverListA . StopAll (); UnregisterAll UnregisterAll() Unregisters every mover from the list immediately 1 MoverListA . UnregisterAll ();","title":"Mover List"},{"location":"CodeReference/MoverList.html#mover-list-object","text":"The Mover List object provides a way to group Movers together and issue commands to every Mover in the list. Alternatively, commands can be sent to individual movers within the list based on their geographic proximity to a track position","title":"Mover List Object"},{"location":"CodeReference/MoverList.html#setup-execution","text":"1 2 // Declaration MoverListA : MoverList ; 1 2 3 4 5 6 7 8 9 // Usage MoverListA . RegisterMover ( Mover [ 1 ] ); MoverListA . RegisterMover ( Mover [ 2 ] ); MoverListA . RegisterMover ( Mover [ 3 ] ); MoverListA . SetAllVelocity ( 1000 ); MoverListA . MoveAllToStation ( Station [ 4 ] ); MoverListA . UnregisterAll ();","title":"Setup &amp; Execution"},{"location":"CodeReference/MoverList.html#methods","text":"","title":"Methods"},{"location":"CodeReference/MoverList.html#getmoverbylocation","text":"GetMoverByLocation( Index : USINT, Position : LREAL, Direction : Tc2_MC2.MC_Direction ) : REFERENCE TO Mover Returns a reference to a singular mover from the Mover List, based on it's geographic location relative to a fixed track position. Index specifies the number of movers that should lie between the selection and the Position input. Therefore Index = 0 would be the closest mover to the input position (in a given direction), Index = 1 would be the second closest, Index = 2 would be the third closest, etc. Position specifies the target around which mover proximity should be considered. Direction specifies the direction around the track from which the movers are indexed. Therefore MC_Positive_Direction will begin returning movers with the most positive absolute position values that are still less than the position input. 1 2 3 4 5 6 7 8 9 10 11 // Select a mover in the MoverList // Which is the first closest mover to position 900 // And which has a position less than 900 // Then sends it to a station MoverListA . GetMoverByLocation ( 0 , 900 , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] ); // Select a mover in the MoverList // Which is the third closest mover to position 2000 // And which has a position greater than 3000 // Then sets its acceleration MoverListA . GetMoverByLocation ( 2 , 3000 , MC_Negative_Direction ). SetAcceleration ( 1E4 );","title":"GetMoverByLocation"},{"location":"CodeReference/MoverList.html#movealltoposition","text":"MoveAllToPosition( DestinationPosition : LREAL ) Issues individual MoveToPosition commands to every mover registered with the list. 1 MoverListA . MoveAllToPosition ( 1200 );","title":"MoveAllToPosition"},{"location":"CodeReference/MoverList.html#movealltostation","text":"MoveAllToStation( DestinationStation: Station ) Issues individual MoveToStation commands to every mover registered with the list. 1 MoverListA . MoveAllToStation ( Station [ 3 ] );","title":"MoveAllToStation"},{"location":"CodeReference/MoverList.html#moveallvelocity","text":"MoveAllVelocity( DesiredVelocity : LREAL ) Issues individual MoveVelocity commands to every mover registered with the list. 1 MoverListA . MoveAllVelocity ( 300 );","title":"MoveAllVelocity"},{"location":"CodeReference/MoverList.html#setallacceleration","text":"SetAllAcceleration( DesiredAcceleration : LREAL ) Sets the acceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllAcceleration ( 1E3 );","title":"SetAllAcceleration"},{"location":"CodeReference/MoverList.html#setalldeceleration","text":"SetAllDeceleration( DesiredDeceleration : LREAL ) Sets the deceleration motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDeceleration ( 15000 );","title":"SetAllDeceleration"},{"location":"CodeReference/MoverList.html#setalldirection","text":"SetAllDirection( Direction : Tc3_Mc3Definitions.MC_DIRECTION ) Sets the direction motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllDirection ( mcDirectionPositive );","title":"SetAllDirection"},{"location":"CodeReference/MoverList.html#setalljerk","text":"SetAllJerk( DesiredJerk : LREAL ) Sets the jerk motion parameter equal to the input argument for every mover in the list 1 MoverListA.SetAllJerk( 1e5 );","title":"SetAllJerk"},{"location":"CodeReference/MoverList.html#setallvelocity","text":"SetAllVelocity( DesiredVelocity : LREAL ) Sets the velocity motion parameter equal to the input argument for every mover in the list 1 MoverListA . SetAllVelocity ( 2000 );","title":"SetAllVelocity"},{"location":"CodeReference/MoverList.html#stopall","text":"StopAll() Stops all movers in the list by calling their individual Stop methods 1 MoverListA . StopAll ();","title":"StopAll"},{"location":"CodeReference/MoverList.html#unregisterall","text":"UnregisterAll() Unregisters every mover from the list immediately 1 MoverListA . UnregisterAll ();","title":"UnregisterAll"},{"location":"CodeReference/Objectives.html","text":"Objectives Overview Objective is an umbrella term used by the project, that includes the following objects: Stations Zones SpeedTriggers PositionTriggers MoverLists Each Objective defines a set criteria that a Mover can either fulfill or not at any given point. As an example, a Mover fulfills the criteria of a Station when it is parked at the Station's configured track position. When a Mover satisfies the requirements of the Objective , the Objective provides a Reference to the Mover through which new Mover commands can be issued. Common Methods The objects listed above all share some common methods, which are implemented in the base parent Objective object. RegisterMover RegisterMover( NewMover : Mover ) Adds a Mover to the list of Tracked Movers that the objective is currently monitoring. If the input Mover has already been added to the Tracked Movers list, the method call is ignored. 1 2 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition ); Station [ 1 ]. RegisterMover ( Mover [ 1 ] ); The code above is similar in functionality to: 1 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Stations include some unique features regarding mover registration. See Station Object for more details. UnregisterMover RegisterMover( ExistingMover : Mover ) Removes a Mover from the list of Tracked Movers that the objective is currently monitoring. If the input Mover is not already tracked by the objective, the method call is ignored. 1 2 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Station [ 1 ]. UnregisterMover ( Mover [ 1 ] ); Because the Mover would not be registered with the Station when it arrives, the Station would not report that the Mover is InPosition. The code above is functionally identical to: 1 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition ); UnregisterCurrent UnregisterCurrent( ) Automatically unregisters whatever mover is listed as CurrentMover for the Objective Here the MoverInPosition status output changes. The mover is still physically located at the Station position, but since it is no longer registered, it cannot report InPosition. 1 2 3 bCheck := Station [ 1 ]. MoverInPosition ; // returns TRUE Station [ 1 ]. UnregisterCurrent (); bCheck := Station [ 1 ]. MoverInPosition ; // returns FALSE 1 2 3 4 IF PositionTrigger [ 1 ]. MoverPassedPosition THEN PositionTrigger [ 1 ]. CurrentMover . SetVelocity ( 200 ); PositionTrigger [ 1 ]. UnregisterCurrent (); END_IF UnregisterAll UnregisterAll() Automatically unregisters every mover from the Tracked Movers list 1","title":"Overview"},{"location":"CodeReference/Objectives.html#objectives","text":"","title":"Objectives"},{"location":"CodeReference/Objectives.html#overview","text":"Objective is an umbrella term used by the project, that includes the following objects: Stations Zones SpeedTriggers PositionTriggers MoverLists Each Objective defines a set criteria that a Mover can either fulfill or not at any given point. As an example, a Mover fulfills the criteria of a Station when it is parked at the Station's configured track position. When a Mover satisfies the requirements of the Objective , the Objective provides a Reference to the Mover through which new Mover commands can be issued.","title":"Overview"},{"location":"CodeReference/Objectives.html#common-methods","text":"The objects listed above all share some common methods, which are implemented in the base parent Objective object.","title":"Common Methods"},{"location":"CodeReference/Objectives.html#registermover","text":"RegisterMover( NewMover : Mover ) Adds a Mover to the list of Tracked Movers that the objective is currently monitoring. If the input Mover has already been added to the Tracked Movers list, the method call is ignored. 1 2 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition ); Station [ 1 ]. RegisterMover ( Mover [ 1 ] ); The code above is similar in functionality to: 1 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Stations include some unique features regarding mover registration. See Station Object for more details.","title":"RegisterMover"},{"location":"CodeReference/Objectives.html#unregistermover","text":"RegisterMover( ExistingMover : Mover ) Removes a Mover from the list of Tracked Movers that the objective is currently monitoring. If the input Mover is not already tracked by the objective, the method call is ignored. 1 2 Mover [ 1 ]. MoveToStation ( Station [ 1 ] ); Station [ 1 ]. UnregisterMover ( Mover [ 1 ] ); Because the Mover would not be registered with the Station when it arrives, the Station would not report that the Mover is InPosition. The code above is functionally identical to: 1 Mover [ 1 ]. MoveToPosition ( Station [ 1 ]. TrackPosition );","title":"UnregisterMover"},{"location":"CodeReference/Objectives.html#unregistercurrent","text":"UnregisterCurrent( ) Automatically unregisters whatever mover is listed as CurrentMover for the Objective Here the MoverInPosition status output changes. The mover is still physically located at the Station position, but since it is no longer registered, it cannot report InPosition. 1 2 3 bCheck := Station [ 1 ]. MoverInPosition ; // returns TRUE Station [ 1 ]. UnregisterCurrent (); bCheck := Station [ 1 ]. MoverInPosition ; // returns FALSE 1 2 3 4 IF PositionTrigger [ 1 ]. MoverPassedPosition THEN PositionTrigger [ 1 ]. CurrentMover . SetVelocity ( 200 ); PositionTrigger [ 1 ]. UnregisterCurrent (); END_IF","title":"UnregisterCurrent"},{"location":"CodeReference/Objectives.html#unregisterall","text":"UnregisterAll() Automatically unregisters every mover from the Tracked Movers list 1","title":"UnregisterAll"},{"location":"CodeReference/PositionTrigger.html","text":"Position Trigger Object Position Trigger objects monitor movers until they have crossed over a specified location on track, even if they do not stop there. Setup & Execution 1 2 // Declaration PositionTriggerA : PositionTrigger ; 1 2 3 // Initialization PositionTriggerA . TrackPosition := 2000 ; PositionTriggerA . TriggerDirection := mcDirectionPositive ; Methods Cyclic Cyclic() Position Triggers require a cyclic call in the Main Program because they need to constantly monitor the positions of registered movers. Properties .MoverPassedPosition Status boolean indicating that at least one mover has passed over the threshold position since being registered Position Triggers are unique in that the Current Mover output latches even though the mover may not still qualify under the trigger condition .CurrentMover Reference variable that refers to the earliest registered mover to cross over the track position since being registered If no movers are tracked, or no tracked movers have yet satisfied the objective, then .CurrentMover is an invalid reference. Attempting to evaluate it will result in a page fault and XAR will stop. It is recommended that all evaluations are nested inside IF checks for .MoverPassedPosition OR by calling __ISVALIDREF It is possible that multiple registered movers have crossed over a threshold position. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with PositionTrigger.UnregisterCurrent() .TrackPosition Current placement of the Position Trigger threshold along the track Extra Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Basic Position Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); PositionTrigger . TrackPosition := 800 ; PositionTrigger . RegisterMover ( Mover [ 1 ] ); bInit := FALSE ; END_IF // When Mover 1 crosses position 800, slow it down to 100mm/s IF PositionTrigger . MoverPassedPosition THEN PositionTrigger . CurrentMover . SetVelocity ( 100 ); PositionTrigger . UnregisterCurrent (); END_IF","title":"Position Trigger"},{"location":"CodeReference/PositionTrigger.html#position-trigger-object","text":"Position Trigger objects monitor movers until they have crossed over a specified location on track, even if they do not stop there.","title":"Position Trigger Object"},{"location":"CodeReference/PositionTrigger.html#setup-execution","text":"1 2 // Declaration PositionTriggerA : PositionTrigger ; 1 2 3 // Initialization PositionTriggerA . TrackPosition := 2000 ; PositionTriggerA . TriggerDirection := mcDirectionPositive ;","title":"Setup &amp; Execution"},{"location":"CodeReference/PositionTrigger.html#methods","text":"","title":"Methods"},{"location":"CodeReference/PositionTrigger.html#cyclic","text":"Cyclic() Position Triggers require a cyclic call in the Main Program because they need to constantly monitor the positions of registered movers.","title":"Cyclic"},{"location":"CodeReference/PositionTrigger.html#properties","text":"","title":"Properties"},{"location":"CodeReference/PositionTrigger.html#moverpassedposition","text":"Status boolean indicating that at least one mover has passed over the threshold position since being registered Position Triggers are unique in that the Current Mover output latches even though the mover may not still qualify under the trigger condition","title":".MoverPassedPosition"},{"location":"CodeReference/PositionTrigger.html#currentmover","text":"Reference variable that refers to the earliest registered mover to cross over the track position since being registered If no movers are tracked, or no tracked movers have yet satisfied the objective, then .CurrentMover is an invalid reference. Attempting to evaluate it will result in a page fault and XAR will stop. It is recommended that all evaluations are nested inside IF checks for .MoverPassedPosition OR by calling __ISVALIDREF It is possible that multiple registered movers have crossed over a threshold position. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with PositionTrigger.UnregisterCurrent()","title":".CurrentMover"},{"location":"CodeReference/PositionTrigger.html#trackposition","text":"Current placement of the Position Trigger threshold along the track","title":".TrackPosition"},{"location":"CodeReference/PositionTrigger.html#extra-examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Basic Position Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); PositionTrigger . TrackPosition := 800 ; PositionTrigger . RegisterMover ( Mover [ 1 ] ); bInit := FALSE ; END_IF // When Mover 1 crosses position 800, slow it down to 100mm/s IF PositionTrigger . MoverPassedPosition THEN PositionTrigger . CurrentMover . SetVelocity ( 100 ); PositionTrigger . UnregisterCurrent (); END_IF","title":"Extra Examples"},{"location":"CodeReference/SpeedTrigger.html","text":"Speed Trigger Object Speed Trigger objects monitor movers until they have exceeded a specified velocity. Setup & Execution 1 2 // Declaration SpeedTriggerA : SpeedTrigger ; 1 2 // Initization SpeedTriggerA . ThresholdVelocity := 800 ; Properties .MoverInVelocity Status boolean indicating that at least one mover is currently exceeding the threshold velocity .CurrentMover Reference variable that refers to the earliest registered mover to exceed the threshold velocity since being registered If no movers are tracked, or no tracked movers currently satisfy the objective, then .CurrentMover is an invalid reference. Attempting to evaluate it will result in a page fault and XAR will stop. It is recommended that all evaluations are nested inside IF check for .MoverInVelocity OR by calling __ISVALIDREF It is possible that multiple registered movers simultaneously exceed the threshold velocity. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with SpeedTrigger.UnregisterCurrent() .ThresholdVelocity Current velocity, above which a mover is considered 'In Velocity' Extra Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Basic Speed Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); SpeedTrigger . ThresholdVelocity := 600 ; // mm/s bInit := FALSE ; END_IF // When Mover 1 accelerates past 600mm/s, slow it down to 100mm/s IF SpeedTrigger . MoverInVelocity THEN SpeedTrigger . CurrentMover . SetVelocity ( 100 ); SpeedTrigger . UnregisterCurrent (); END_IF","title":"Speed Trigger"},{"location":"CodeReference/SpeedTrigger.html#speed-trigger-object","text":"Speed Trigger objects monitor movers until they have exceeded a specified velocity.","title":"Speed Trigger Object"},{"location":"CodeReference/SpeedTrigger.html#setup-execution","text":"1 2 // Declaration SpeedTriggerA : SpeedTrigger ; 1 2 // Initization SpeedTriggerA . ThresholdVelocity := 800 ;","title":"Setup &amp; Execution"},{"location":"CodeReference/SpeedTrigger.html#properties","text":"","title":"Properties"},{"location":"CodeReference/SpeedTrigger.html#moverinvelocity","text":"Status boolean indicating that at least one mover is currently exceeding the threshold velocity","title":".MoverInVelocity"},{"location":"CodeReference/SpeedTrigger.html#currentmover","text":"Reference variable that refers to the earliest registered mover to exceed the threshold velocity since being registered If no movers are tracked, or no tracked movers currently satisfy the objective, then .CurrentMover is an invalid reference. Attempting to evaluate it will result in a page fault and XAR will stop. It is recommended that all evaluations are nested inside IF check for .MoverInVelocity OR by calling __ISVALIDREF It is possible that multiple registered movers simultaneously exceed the threshold velocity. Only the least recently valid mover handle is provided by .CurrentMover. To access more recent events, deregister the current mover with SpeedTrigger.UnregisterCurrent()","title":".CurrentMover"},{"location":"CodeReference/SpeedTrigger.html#thresholdvelocity","text":"Current velocity, above which a mover is considered 'In Velocity'","title":".ThresholdVelocity"},{"location":"CodeReference/SpeedTrigger.html#extra-examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Basic Speed Trigger implementation // Begin monitoring Mover 1 IF bInit THEN Mover [ 1 ]. MoveToPosition ( 1000 ); SpeedTrigger . ThresholdVelocity := 600 ; // mm/s bInit := FALSE ; END_IF // When Mover 1 accelerates past 600mm/s, slow it down to 100mm/s IF SpeedTrigger . MoverInVelocity THEN SpeedTrigger . CurrentMover . SetVelocity ( 100 ); SpeedTrigger . UnregisterCurrent (); END_IF","title":"Extra Examples"},{"location":"CodeReference/Station.html","text":"Station Object The Station object provides a fixed location for a Mover to stop at until it is ready to be released. A Station is a type of Objective, and provides a handle to the Mover object that is currently docked with the Station, allowing further motion commands to be issued to the Mover. Setup & Execution 1 2 // Declaration Station : ARRAY [ 0. . GVL . NUM_STATIONS - 1 ] OF Station ; 1 2 3 4 // Initialization Station [ 1 ]. TrackPosition := 250 ; Station [ 2 ]. TrackPosition := 500 ; Station [ 3 ]. TrackPosition := 750 ; 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic (); END_FOR Mover Registration Unlike other types of Objectives, Stations manage mover registration automatically. Any mover that is commanded with a MoveToStation is also automatically registered with that station. As an example, this implementation would be redundant: 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Station [ 3 ]. RegisterMover ( Mover [ 2 ] ); // unnecessary Stations also automatically unregister movers that have been redirected with another move command, even if that command's destination is the same as the Station. 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Mover [ 2 ]. MoveToPosition ( Station [ 3 ]. TrackPosition ); Here, the Station will not report MoverInPosition . Methods Cyclic Cyclic() Stations require a cyclic call in the Main program. This allows the station to automatically unregister movers from its Tracked list who have been redirected and are no longer destined for this Station. 1 2 3 FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic () END_FOR Properties .MoverInPosition Status boolean indicating that a mover is currently docked with the Station .CurrentMover Reference variable that refers to the Mover that is docked with the Station When no mover is present in the Station, .CurrentMover is an invalid reference. Attempting to evaluate it will result in a page fault and XAR will stop. It is recommended that all evaluations are nested inside IF checks for .MoverInPosition OR by calling __ISVALIDREF .TrackedMoverCount Simply reports the number of Movers that are currently registered with the Station. Because Stations automatically deregister movers that are not currently destined for this Station, this value also represents the current number of incoming movers .TrackPosition Current placement of the Station along the track Extra Examples 1 2 3 4 5 6 7 8 9 10 // Basic Station implementation with a 1s dwell time IF Station [ 0 ]. MoverInPosition THEN StationTimer ( IN := TRUE , PT := T # 1000 MS ); // TON IF StationTimer . Q THEN Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE StationTimer ( IN := FALSE ); END_IF 1 2 3 4 // Immediately redirect all incoming shuttles to Station 1 instead of Station 0 FOR i := 0 TO Station [ 0 ]. TrackedMoverCount - 1 DO Station [ 0 ]. TrackedMovers [ i ] ^ . MoveToStation ( Station [ 1 ] ); END_FOR","title":"Station"},{"location":"CodeReference/Station.html#station-object","text":"The Station object provides a fixed location for a Mover to stop at until it is ready to be released. A Station is a type of Objective, and provides a handle to the Mover object that is currently docked with the Station, allowing further motion commands to be issued to the Mover.","title":"Station Object"},{"location":"CodeReference/Station.html#setup-execution","text":"1 2 // Declaration Station : ARRAY [ 0. . GVL . NUM_STATIONS - 1 ] OF Station ; 1 2 3 4 // Initialization Station [ 1 ]. TrackPosition := 250 ; Station [ 2 ]. TrackPosition := 500 ; Station [ 3 ]. TrackPosition := 750 ; 1 2 3 4 // Call this method cyclically FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic (); END_FOR","title":"Setup &amp; Execution"},{"location":"CodeReference/Station.html#mover-registration","text":"Unlike other types of Objectives, Stations manage mover registration automatically. Any mover that is commanded with a MoveToStation is also automatically registered with that station. As an example, this implementation would be redundant: 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Station [ 3 ]. RegisterMover ( Mover [ 2 ] ); // unnecessary Stations also automatically unregister movers that have been redirected with another move command, even if that command's destination is the same as the Station. 1 2 Mover [ 2 ]. MoveToStation ( Station [ 3 ] ); Mover [ 2 ]. MoveToPosition ( Station [ 3 ]. TrackPosition ); Here, the Station will not report MoverInPosition .","title":"Mover Registration"},{"location":"CodeReference/Station.html#methods","text":"","title":"Methods"},{"location":"CodeReference/Station.html#cyclic","text":"Cyclic() Stations require a cyclic call in the Main program. This allows the station to automatically unregister movers from its Tracked list who have been redirected and are no longer destined for this Station. 1 2 3 FOR i := 0 TO GVL . NUM_STATIONS - 1 DO Station [ i ]. Cyclic () END_FOR","title":"Cyclic"},{"location":"CodeReference/Station.html#properties","text":"","title":"Properties"},{"location":"CodeReference/Station.html#moverinposition","text":"Status boolean indicating that a mover is currently docked with the Station","title":".MoverInPosition"},{"location":"CodeReference/Station.html#currentmover","text":"Reference variable that refers to the Mover that is docked with the Station When no mover is present in the Station, .CurrentMover is an invalid reference. Attempting to evaluate it will result in a page fault and XAR will stop. It is recommended that all evaluations are nested inside IF checks for .MoverInPosition OR by calling __ISVALIDREF","title":".CurrentMover"},{"location":"CodeReference/Station.html#trackedmovercount","text":"Simply reports the number of Movers that are currently registered with the Station. Because Stations automatically deregister movers that are not currently destined for this Station, this value also represents the current number of incoming movers","title":".TrackedMoverCount"},{"location":"CodeReference/Station.html#trackposition","text":"Current placement of the Station along the track","title":".TrackPosition"},{"location":"CodeReference/Station.html#extra-examples","text":"1 2 3 4 5 6 7 8 9 10 // Basic Station implementation with a 1s dwell time IF Station [ 0 ]. MoverInPosition THEN StationTimer ( IN := TRUE , PT := T # 1000 MS ); // TON IF StationTimer . Q THEN Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE StationTimer ( IN := FALSE ); END_IF 1 2 3 4 // Immediately redirect all incoming shuttles to Station 1 instead of Station 0 FOR i := 0 TO Station [ 0 ]. TrackedMoverCount - 1 DO Station [ 0 ]. TrackedMovers [ i ] ^ . MoveToStation ( Station [ 1 ] ); END_FOR","title":"Extra Examples"},{"location":"CodeReference/Zone.html","text":"Zone Object The Zone object provides a method for grabbing all Movers within a specified geographic area on the track. A Zone is defined by a Start Position and an End Position, and returns every mover between these points. Zones are especially useful for programming recovery scenarios. Setup & Execution 1 2 3 // Declaration ZoneLeftSide : Zone ; ZoneRightSide : Zone ; 1 2 3 4 5 6 // Initialization ZoneLeftSide . StartPosition := 0 ; ZoneLeftSide . EndPosition := 2000 ; ZoneRightSide . StartPosition := 2000 ; ZoneRightSide . EndPosition := 4000 ; Methods GetMover GetMover( Index : USINT, Direction : Tc2_MC2.MC_Direction) : REFERENCE TO Mover Provides a reference to the Mover that has n = Index movers between it and the end of the Zone specified by the Direction 1 2 3 4 5 6 7 // Selects the mover closest to the Zone's End Position // Then issues a motion command ZoneLeftSide . GetMover ( 0 , MC_Positive_Direction ). MoveToPosition ( 2000 ); // Selects the fourth-closest mover to the Zone's Start Position // Then sets its velocity ZoneRightSide . GetMover ( 3 , MC_Negative_Direction ). SetVelocity ( 1200 ); Properties .CurrentMoverList Provides a MoverList object reference, containing all Movers that are currently within the boundaries set by Start Position and End Position. As a MoverList, methods are provided to command all movers as a group. See MoverList objective for more information 1 2 3 4 5 6 7 8 // Command all movers from position 0 through 2000 to Station#1 ZoneLeftSide . CurrentMoverList . MoveAllToStation ( Station [ 1 ] ); // Command all movers from position 2000 through 4000 to Station#2 ZoneRightSide . CurrentMoverList . MoveAllToStation ( Station [ 2 ] ); // Command the singular mover which is closest to the end of the zone to Station#3 Zone . CurrentMoverList . GetMoverByLocation ( 0 , Zone . EndPosition , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] ); .StartPosition Defines the lower bound for the track region considered by the Zone object. .EndPosition Defines the upper bound for the track region considered by the Zone object. .ZoneLength Calculates the length of the defined zone, in millimeters.","title":"Zone"},{"location":"CodeReference/Zone.html#zone-object","text":"The Zone object provides a method for grabbing all Movers within a specified geographic area on the track. A Zone is defined by a Start Position and an End Position, and returns every mover between these points. Zones are especially useful for programming recovery scenarios.","title":"Zone Object"},{"location":"CodeReference/Zone.html#setup-execution","text":"1 2 3 // Declaration ZoneLeftSide : Zone ; ZoneRightSide : Zone ; 1 2 3 4 5 6 // Initialization ZoneLeftSide . StartPosition := 0 ; ZoneLeftSide . EndPosition := 2000 ; ZoneRightSide . StartPosition := 2000 ; ZoneRightSide . EndPosition := 4000 ;","title":"Setup &amp; Execution"},{"location":"CodeReference/Zone.html#methods","text":"","title":"Methods"},{"location":"CodeReference/Zone.html#getmover","text":"GetMover( Index : USINT, Direction : Tc2_MC2.MC_Direction) : REFERENCE TO Mover Provides a reference to the Mover that has n = Index movers between it and the end of the Zone specified by the Direction 1 2 3 4 5 6 7 // Selects the mover closest to the Zone's End Position // Then issues a motion command ZoneLeftSide . GetMover ( 0 , MC_Positive_Direction ). MoveToPosition ( 2000 ); // Selects the fourth-closest mover to the Zone's Start Position // Then sets its velocity ZoneRightSide . GetMover ( 3 , MC_Negative_Direction ). SetVelocity ( 1200 );","title":"GetMover"},{"location":"CodeReference/Zone.html#properties","text":"","title":"Properties"},{"location":"CodeReference/Zone.html#currentmoverlist","text":"Provides a MoverList object reference, containing all Movers that are currently within the boundaries set by Start Position and End Position. As a MoverList, methods are provided to command all movers as a group. See MoverList objective for more information 1 2 3 4 5 6 7 8 // Command all movers from position 0 through 2000 to Station#1 ZoneLeftSide . CurrentMoverList . MoveAllToStation ( Station [ 1 ] ); // Command all movers from position 2000 through 4000 to Station#2 ZoneRightSide . CurrentMoverList . MoveAllToStation ( Station [ 2 ] ); // Command the singular mover which is closest to the end of the zone to Station#3 Zone . CurrentMoverList . GetMoverByLocation ( 0 , Zone . EndPosition , MC_Positive_Direction ). MoveToStation ( Station [ 3 ] );","title":".CurrentMoverList"},{"location":"CodeReference/Zone.html#startposition","text":"Defines the lower bound for the track region considered by the Zone object.","title":".StartPosition"},{"location":"CodeReference/Zone.html#endposition","text":"Defines the upper bound for the track region considered by the Zone object.","title":".EndPosition"},{"location":"CodeReference/Zone.html#zonelength","text":"Calculates the length of the defined zone, in millimeters.","title":".ZoneLength"},{"location":"Examples/StationRouting.html","text":"Station Routing This example demonstrates the most basic Station to Station type routing. There are two stations, which each dwell for a period of time before forwarding movers to the next station in the sequence 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 MS_RUN : // ----------------------------------- OPERATING // Station 0 Logic IF Station [ 0 ]. MoverInPosition THEN StationTimer [ 0 ]( IN := TRUE , PT := T # 1000 MS ); IF StationTimer [ 0 ]. Q THEN Station [ 0 ]. CurrentMover . SetVelocity ( 500 ); Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 0 ]( IN := FALSE ); END_IF // Station 1 Logic IF Station [ 1 ]. MoverInPosition THEN StationTimer [ 1 ]( IN := TRUE , PT := T # 2 s ); IF StationTimer [ 1 ]. Q THEN // Same behavior as above, but utilizing method chaining Station [ 1 ]. CurrentMover . SetVelocity ( 90 ). MoveToStation ( Station [ 0 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 1 ]( IN := FALSE ); END_IF","title":"Station Routing"},{"location":"Examples/StationRouting.html#station-routing","text":"This example demonstrates the most basic Station to Station type routing. There are two stations, which each dwell for a period of time before forwarding movers to the next station in the sequence 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 MS_RUN : // ----------------------------------- OPERATING // Station 0 Logic IF Station [ 0 ]. MoverInPosition THEN StationTimer [ 0 ]( IN := TRUE , PT := T # 1000 MS ); IF StationTimer [ 0 ]. Q THEN Station [ 0 ]. CurrentMover . SetVelocity ( 500 ); Station [ 0 ]. CurrentMover . MoveToStation ( Station [ 1 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 0 ]( IN := FALSE ); END_IF // Station 1 Logic IF Station [ 1 ]. MoverInPosition THEN StationTimer [ 1 ]( IN := TRUE , PT := T # 2 s ); IF StationTimer [ 1 ]. Q THEN // Same behavior as above, but utilizing method chaining Station [ 1 ]. CurrentMover . SetVelocity ( 90 ). MoveToStation ( Station [ 0 ] ); END_IF ELSE // Reset the timer for the next mover StationTimer [ 1 ]( IN := FALSE ); END_IF","title":"Station Routing"},{"location":"GettingStarted/GettingStarted.html","text":"Getting Started Project Requirements For new projects, the latest versions of TwinCAT and XTS software should be utilized. All XTS projects will require: TF5850 TF5410 Configuring XTS Hardware The base project includes a simulated configuration for a 4m oval track and 6 movers. In order to modify the program to fit a different track configuration, navigate to the XTS Tool Window. Then launch the XTS Configurator and follow the prompts to configure your system. The configurator occasionally conflicts with existing settings in the project. To avoid this, it can help to delete the following prior to running the XTS Configurator: XtsProcessingUnit All Mover Axis Object Existing XTS_Task Any hardware in the IO section. Initialization Settings Once your hardware configuration is set, you will need to change a few variable parameters in the code to match the system. Inside MOTION > Objects > Collision Avoidance (CA Group) , set the Rail Length parameter to match your hardware. Next, open the GVL file within PLC and modify these constants to match your system. Next, check that each of your Axis objects are properly linked to a corresponding Mover object. Lastly, open the XtsProcessingUnit within SYSTEM and verify that every setting here is correct","title":"First Steps"},{"location":"GettingStarted/GettingStarted.html#getting-started","text":"","title":"Getting Started"},{"location":"GettingStarted/GettingStarted.html#project-requirements","text":"For new projects, the latest versions of TwinCAT and XTS software should be utilized. All XTS projects will require: TF5850 TF5410","title":"Project Requirements"},{"location":"GettingStarted/GettingStarted.html#configuring-xts-hardware","text":"The base project includes a simulated configuration for a 4m oval track and 6 movers. In order to modify the program to fit a different track configuration, navigate to the XTS Tool Window. Then launch the XTS Configurator and follow the prompts to configure your system. The configurator occasionally conflicts with existing settings in the project. To avoid this, it can help to delete the following prior to running the XTS Configurator: XtsProcessingUnit All Mover Axis Object Existing XTS_Task Any hardware in the IO section.","title":"Configuring XTS Hardware"},{"location":"GettingStarted/GettingStarted.html#initialization-settings","text":"Once your hardware configuration is set, you will need to change a few variable parameters in the code to match the system. Inside MOTION > Objects > Collision Avoidance (CA Group) , set the Rail Length parameter to match your hardware. Next, open the GVL file within PLC and modify these constants to match your system. Next, check that each of your Axis objects are properly linked to a corresponding Mover object. Lastly, open the XtsProcessingUnit within SYSTEM and verify that every setting here is correct","title":"Initialization Settings"},{"location":"GettingStarted/Introduction.html","text":"Introduction This site serves as reference documentation for the XTS Base Project. This site is not intended as a complete training guide on the XTS system, and contains no information on the electrical or mechanical setup of the system. Additional Resources Project Github Beckhoff XTS Page","title":"Introduction"},{"location":"GettingStarted/Introduction.html#introduction","text":"This site serves as reference documentation for the XTS Base Project. This site is not intended as a complete training guide on the XTS system, and contains no information on the electrical or mechanical setup of the system.","title":"Introduction"},{"location":"GettingStarted/Introduction.html#additional-resources","text":"Project Github Beckhoff XTS Page","title":"Additional Resources"}]}