{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CodeReference/Diagnostics/Basics.html","title":"Basic Diagnostics","text":"<p>Project Diagnostics in this documentation focuses on troubleshooting during active project development, and does not provide functionality for Alarm Handling on a production system. Those functionalities must be added to this project on an application-specific basis.</p> <p>Several tools are made available in this project file to make development as quick and easy as possible, such as:</p> <ul> <li>Object status information</li> <li>Function block error codes</li> <li>Mover activity Event Log</li> <li>User Log Events</li> </ul> <p>As a starting point, always be sure to investigate the object status outputs in the variable viewer inside TwinCAT. Here we can immediately see a Mover which is:</p> <ul> <li>Currently destined for Station #0</li> <li>Most recently commanded via Position Trigger #2</li> <li>Has no active errors</li> </ul> <p>For more advanced troubleshooting steps, see the additional categories to the left.</p> <p></p>"},{"location":"CodeReference/Diagnostics/ErrorMovers.html","title":"ErrorMovers","text":""},{"location":"CodeReference/Diagnostics/ErrorMovers.html#invalid-references","title":"Invalid References","text":"<p>Objectives that return References to MoverLists or Movers have the potential to return invalid references. For example, a Station with no mover present can't possibly return a CurrentMover, because by definition no CurrentMover exists! To prevent this, it is important to ensure that all CurrentMover and CurrentMoverList output properties are only evaluated when a MoverInPosition, MoverPassedPosition, MoverInVelocity, etc. flag is true for the relevant Objective.</p> <pre><code>// There is no CurrentMover at the Station, so this code will not operate correctly!!\nIF Station[1].MoverInPosition = FALSE THEN\n    Station[1].CurrentMover.MoveToPosition( 200 );\nEND_IF\n</code></pre> <p>Typically, calling methods on these invalid references would result in a Pagefault and halt the XAR. However this outcome can be frustrating and slows development. Instead, an imposter ErrorMover object is returned in these circumstances as a quality-of-life improvement. ErrorMovers replace all the method functionality of standard Movers and will instead generate Errors in TwinCAT. For example:</p> <p></p>"},{"location":"CodeReference/Diagnostics/ErrorMovers.html#axis-linking","title":"Axis Linking","text":"<p>If ErrorMovers appear in the list of potentially linkable objects when connecting NC Axes to PLC axes, ensure that these objects are not selected.</p> <p>By default, ErrorMovers are removed from the PLC Process Image to prevent them appearing in this list.</p> <p></p>"},{"location":"CodeReference/Diagnostics/EventLogger.html","title":"Event Logger","text":"<p>When the occasional programmed instruction leads to unexpected Mover behavior, it can be useful to look back at a logged history of Mover Events.</p> <p>In this project, every command issued to any Mover on the track is submitted as a log entry which can be viewed in TwinCAT:</p> <p></p>"},{"location":"CodeReference/Diagnostics/EventLogger.html#user-events","title":"User Events","text":"<p>To make filtering through these events even easier, customer User Events can also be submitted to the Log.</p> <p>See Mover.LogUserEvent for more information.</p>"},{"location":"CodeReference/Diagnostics/MoverData.html","title":"XTS.MoverData","text":""},{"location":"CodeReference/Diagnostics/MoverData.html#use","title":"Use","text":"<p>The outputs from the <code>XTS</code> (FB_XTS) object in the <code>MAIN</code> POU consolidates some commonly used mover information into one space to help simplify basic troubleshooting.</p> <p>The information included in the MoverData GVL is:</p> <ul> <li>MoverPositions - a REAL representing the current position of the mover on the track.</li> <li>MoverErrors - a BOOL when true indicates that there is an error with this mover.</li> <li>MoverErrorIDs - a UDINT with an error code produced this mover. Error codes can be looked up in Beckhoff Infosys.</li> </ul> <p></p>"},{"location":"CodeReference/Diagnostics/MoverData.html#fieldbus","title":"Fieldbus","text":"<p>The data in MAIN.XTS outputs has deliberately been chosen to use arrays of elementary data types that can be sent through most field buses in their default configuration. This can help facilitate status and error annunciation a higher level control system if one is used.</p>"},{"location":"CodeReference/Diagnostics/UtilityLibrary.html","title":"Utility Library","text":""},{"location":"CodeReference/Diagnostics/UtilityLibrary.html#tc3_xts_utility","title":"Tc3_XTS_Utility","text":"<p>The XTS Utility library is installed as a component of TF5850 and provides advanced-level access to a huge amount of data and functionality in the XTS system. Nearly every value, parameter, or setting visible in the various windows of the XTS Configuration is accessible via this library.</p> <p>Things like module temperatures, coil currents, and segment BTNs can all be read from the track system using this library. Write-access is provided to some parameters, allowing additional functionality like: on-the-fly tuning changes, manually triggering mover detection, and more.</p>"},{"location":"CodeReference/Diagnostics/UtilityLibrary.html#documentation","title":"Documentation","text":"<p>Specific library documentation for Tc3_XTS_Utility can be found on Infosys in the link below.</p> <p>Infosys Tc3 XTS Utility Documentation</p>"},{"location":"CodeReference/Diagnostics/UtilityLibrary.html#base-project-use","title":"Base Project Use","text":""},{"location":"CodeReference/Diagnostics/UtilityLibrary.html#code-objects","title":"Code Objects","text":"<p>An instance of the library's core object, FB_TcIoXtsEnvironment, is included in the Base Project for your use. Code within the Mediator also makes use of the utility library to perform bootstrapping functions such as mover 1 identification.</p> <p>More code examples are provided in the Examples section below. Often, you can search through the interface inside TwinCAT using autocomplete to find the information you're looking for.</p>"},{"location":"CodeReference/Diagnostics/UtilityLibrary.html#diagnostic-visu","title":"Diagnostic VISU","text":"<p>An organized Diagnostic PLC VISU is also provided by the library, and has been added to this project. It contains a preconfigured GUI to check diagnostics for the XTS driver, parts, modules, movers, and tracks.</p> <p>More information on this visualization tool is also available on the official Infosys page.</p>"},{"location":"CodeReference/Diagnostics/UtilityLibrary.html#general-pattern","title":"General pattern","text":"<p>The accessors and methods in the XTS utility library refer to objects in a hierarchical order and contain groups of objects. For example, to access a motor module you must navigate through the XPU &gt; Part &gt; Module. It is also possible to have more than one XPU (XTS Processing Unit) on a system.</p> <p>In the above example there is likely more than one part within the system, and multiple motor modules within the system. It is already recommended that you first query adjacent properties for the number of parts (motor modules, movers, etc) and do bounds checking before directly accessing an item.</p> <p>The examples below show both how to query for the number of objects, and how to access data within those objects.</p>"},{"location":"CodeReference/Diagnostics/UtilityLibrary.html#example-usage","title":"Example Usage","text":"<p>All examples should first check for the XTS Environment to be ready. This is handled by the base code automatically, but takes several PLC scans to complete.</p> <pre><code>// check that the XTS environment is ready\nIF XTS.System.EnvironmentIsReady THEN\n    // work with environment variables\nEND_IF\n</code></pre> <pre><code>// Get the number of Parts configured on the system\nmyPartCount := XTS.System.Environment.XpuTcIo(1).GetPartCount();\n</code></pre> <pre><code>// Get the number of Motor Modules configured on the system\nmyMotorCount    := fbXtsEnvironment.XpuTcIo(1).PartTcIo(1).GetModuleCount();\n</code></pre> <pre><code>// get the number of movers in the system\nmyMoverCount := XTS.System.Environment.XpuTcIo(1).GetMoverCount()\n\n// Get the total distance travelled for a all movers\nFOR i := 1 TO myMoverCount DO\n    // read the distance travelled per mover\n    moverTotalDistance := moverTotalDistance + fbXtsEnvironment.XpuTcIo(1).MoverTcIo(i).GetDistanceDrivenInKm();\nEND_FOR;\n</code></pre> <pre><code>// Update mover tuning parameter (must be done with care)\nfbXtsEnvironment.XpuTcIo(1).MoverTcIo(1).SoftDrive.VelocityControl.SetKp(1.5);\n</code></pre>"},{"location":"CodeReference/Objects/Mediator.html","title":"Mediator","text":""},{"location":"CodeReference/Objects/Mediator.html#broad-concept","title":"Broad Concept","text":"<p>Most mover actions can be represented as a combination of a Station, Position Trigger or Zone and a mover. However there are some system-level concepts that require knowledge of all of the stations, movers, zones, etc. The Mediator fulfills this role.</p> <p>By using the system level Mediator, functionality such as next and previous movers can be realized and tasks that need to be called once for the entire system can be managed such as locating Mover 1 at startup.</p> <p>Finally, the Mediator handles calling the necessary <code>.Cyclic()</code> methods on all objects within the system, simplifying code needed to be managed by the end user.</p> <p>In this code the Mediator object is instantiated as the variable <code>System()</code>. </p>"},{"location":"CodeReference/Objects/Mediator.html#configuration","title":"Configuration","text":"<p>Code already exists to make the mediator aware of all Movers, MoverLists, PositionTriggers, Stations, Zones and Tracks. It is executed at the appropriate states in the MAIN program. However, the mediator must be made aware of the number of each object. This is accomplished in the global variable list GVL.</p> <p></p> <p>Update the count of each object according to the needs of the system in this list. It's recommended to oversize these arrays so that during runtime debugging additional stations, zones or position triggers can be added without the need to stop and recompile the PLC program.</p>"},{"location":"CodeReference/Objects/Mediator.html#methods","title":"Methods","text":""},{"location":"CodeReference/Objects/Mediator.html#cyclic","title":"Cyclic","text":"<p>Cyclic()</p> <p>Required to be called once per scan. The Mediator will then call all necessary .Cyclic() methods for the objects that are registered to it.</p>"},{"location":"CodeReference/Objects/Mediator.html#resetstatistics","title":"ResetStatistics","text":"<p>ResetStatistics()</p> <p>Some objects provide statistics that can be used to monitor throughput, utilization, mover velocites and other values and their averages. This method resets all of the statistics collected back to zero after which they begin monitor their values again.</p>"},{"location":"CodeReference/Objects/Mediator.html#other-methods","title":"Other Methods","text":"<p>The following methods are used internally by the Mediator and are not intended for direct access.</p> <ul> <li>AddMover</li> <li>AddMoverList</li> <li>AddPositionTrigger</li> <li>AddStation</li> <li>AddTrack</li> <li>AddZone</li> <li>EnableGroup</li> </ul>"},{"location":"CodeReference/Objects/Mediator.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/Mediator.html#completemoverlist","title":"CompleteMoverList","text":"<p>MoverList</p> <p>Returns a list of all movers within the system.</p> <pre><code>System.CompleteMoverList.HaltAll();\n</code></pre>"},{"location":"CodeReference/Objects/Mediator.html#environment","title":"Environment","text":"<p>I_TcIoXtsEnvironment</p> <p>Returns the environment of this XTS system. The Mediator initializes FB_TcIoXtsEnvironment and the info server and provides this as a convenience.</p> <p>This property should always be used after checking if the environment is initialized.</p> <pre><code>IF (System.EnvironmentIsReady) THEN\n    System.Environment.GetXpuCount(TRUE);\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mediator.html#environmentisready","title":"EnvironmentIsReady","text":"<p>BOOL</p> <p>Returns the status of the initialization of FB_TcIoXtsEnvironment.</p> <p>The Mediator initializes FB_TcIoXtsEnvironment and the info server and returns this as a convenience status.</p> <pre><code>IF (System.EnvironmentIsReady) THEN\n    // examine an Environment parameter or call a method\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mediator.html#groupenabled","title":"GroupEnabled","text":"<p>BOOL</p> <p>Returns the status of the collision avoidance group enabled state. This is the response from the method .EnableGroup();</p>"},{"location":"CodeReference/Objects/Mediator.html#grouperror","title":"GroupError","text":"<p>BOOL</p> <p>If an error is generated by the collision avoidance group it is GroupError is true.</p>"},{"location":"CodeReference/Objects/Mediator.html#infoserver","title":"InfoServer","text":"<p>I_TcIoXtsInfoServer</p> <p>Returns the info server of the XTS system.</p> <p>The Mediator initializes FB_TcIoXtsEnvironment followed by FB_TcIoXtsInfoServer and provides the info server as a convenience.</p> <p>This property should always be used after checking if the environment is initialized and the info server is initialized.</p> <pre><code>IF (System.EnvironmentIsReady) THEN\n    InfoStationCount := System.InfoServer.GetInfoStationCount();\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mediator.html#infoserverisready","title":"InfoServerIsReady","text":"<p>BOOL Returns the status of the initialization of FB_TcIoXtsInfoServer.</p> <p>The Mediator initializes FB_TcIoXtsEnvironment followed by FB_TcIoXtsInfoServer and provides the info server as a convenience status.</p> <pre><code>IF (System.InfoServerIsReady) THEN\n    // examine an InfoServer object\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mediator.html#mover1detectioncomplete","title":"Mover1DetectionComplete","text":"<p>BOOL</p> <p>Returns the status of the mover 1 detection. This is the response from the method .DetectMover1();</p>"},{"location":"CodeReference/Objects/Mediator.html#xpu","title":"XPU","text":"<p>\u00adI_TcIoXtsProcessingUnit</p> <p>Returns the XTS Processing Unit of the XTS system.</p> <p>The Mediator initializes FB_TcIoXtsEnvironment and then provides this interface to the XPU as a convenience.</p> <p>This property should always be used after checking if the environment is initialized and the info server is initialized.</p> <pre><code>IF (System.EnvironmentIsReady) THEN\n    Mode := System.XPU.GetOperationMode();\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html","title":"Mover Object","text":"<p>The Mover function block is the heart of the solution. It contains essential functionality, including:</p> <ul> <li>Basic administrative commands like enabling &amp; disabling</li> <li>Easily commanding movements to absolute positions or stations</li> <li>Reading out current move status information like position, velocity, etc.</li> <li>Updating motion parameters during operation</li> </ul> <p>Many of the motion related commands are chainable as noted below. This allows a concise set of motion commands to be written on one line.</p> <pre><code>// chained motion command that sets velocity, acceleration and a destination in one line\nMover[1].SetVelocity(1000).SetAcceleration(1e3).MoveToStation(Station[2]);\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#setup-execution","title":"Setup &amp; Execution","text":"<p>It is recommended, but not required, to declare Movers as an array. <pre><code>// Instance declaration\nMover           : ARRAY [1..GVL.NUM_MOVERS] OF Mover;\n</code></pre></p> <p>Movers must also be added to the Mediator object. By default, this is handled automatically.</p> <pre><code>// Example implementation\nMediator.AddMover( Mover[1] );\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#methods","title":"Methods","text":""},{"location":"CodeReference/Objects/Mover.html#activatetrack","title":"ActivateTrack","text":"<p>ActivateTrack( DesiredTrack : Track )</p> <p>Updates the mover's logical track.</p> <p>This method is used with track management to change the track that the mover is assigned to. Two conditions should be considered when changing tracks:</p> <ul> <li>A mover will stop immediately when ActivateTrack is called. It's recommended to only change tracks when the mover is in standstill</li> <li>A mover's position can change when calling ActivateTrack. This will happen if the zero point for the current track and new track are different.</li> </ul> <p>A track change takes several PLC and NC scans. Issuing a motion command while this change is in progress will cause the mover to throw an error. To check if the track change is complete monitor the <code>Mover.IsTrackReady</code> property.</p> <pre><code>// state machine\n100:\n    Mover[1].ActivateTrack(Track1);\n    IF (Mover[1].IsTrackReady) THEN\n        iState := 200;\n    END_IF;\n200:\n    // mover is ready for additional commands\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#cyclic","title":"Cyclic","text":"<p>Cyclic()</p> <p>Handles background tasks for the mover such as populating status bits and handling completion of tasks that take more than 1 scan.</p> <p>Important</p> <p>Cyclic must be called every cycle. By default this is handled automatically by the Mediator.</p>"},{"location":"CodeReference/Objects/Mover.html#disable","title":"Disable","text":"<p>Disable()</p> <p>Chainable</p> <p>Disables the mover. Holding Torque will be lost. Method will automatically remove the mover from its Collision Avoidance group.</p> <pre><code>Mover[1].Disable();\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#enable","title":"Enable","text":"<p>Enable()</p> <p>Chainable</p> <p>Carries out steps to prepare the Mover for motion commands.</p> <ol> <li>An internal MC_Reset function block is called to reset any errors that may exist on the Axis object.</li> <li>The mover, via the Mediator, will read M1 Detection Settings configured in the XtsProcessingUnit. If M1 Detection is configured, it will activate this process to find Mover 1. If this is not configured, this step is skipped.</li> <li>An internal MC_Power function block is called to energize the axis object.</li> <li>The mover will automatically add itself to a Collision Avoidance group, and if necessary will also automatically enable this group.</li> <li>The mover will set its <code>Ready</code> output True.</li> </ol> <pre><code>Mover[1].Enable();\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#groupstop","title":"GroupStop","text":"<p>GroupStop()</p> <p>Chainable</p> <p>Immediately stops all enabled movers on the system with the deceleration parameters of the mover on which the method was called.</p> <p>Since the method acts upon the collision avoidance group, all enabled movers on the system are immediately stopped and any active movements are cancelled. New motion commands to each mover are ignored until the Stop has completed.</p> <pre><code>IF xStopAllMovers THEN\n    Mover[1].GroupStop();\n    xStopAllMovers      := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#halt","title":"Halt","text":"<p>Halt()</p> <p>Chainable</p> <p>Immediately stops the commanded mover with the deceleration parameters stored in the Mover object</p> <p>Halt does not alter the mover's internal axis state, so new movements can be executed at any point to send the mover onwards.</p> <pre><code>IF xStopSingleMover THEN\n    Mover[1].Halt();\n    xStopSingleMover    := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#loguserevent","title":"LogUserEvent","text":"<p>LogUserEvent( Text1 : STRING, Text2 : STRING, Text3 : STRING )</p> <p>Chainable</p> <p>Submits custom log events to the Event Logger which can be viewed in TwinCAT</p> <pre><code>IF PositionTrigger[1].MoverPassedPosition THEN\n    PositionTrigger[1].CurrentMover.LogUserEvent('Mover Passed PT#1','','');\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#movetoposition","title":"MoveToPosition","text":"<p>MoveToPosition( Destination : LREAL )</p> <p>Chainable</p> <p>Executes an Absolute Move (with Collision Avoidance) to the target location.</p> <pre><code>IF xMoveCommand THEN\n    Mover[1].MoveToPosition( 1200 );\n    xMoveCommand    := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#movetostation","title":"MoveToStation","text":"<p>MoveToStation( Destination : Station )</p> <p>Chainable</p> <p>Executes an Absolute Move (with Collision Avoidance) to the location of the target Station, and implicitly calls that Station's RegisterMover method.</p> <pre><code>IF xMoveToHome THEN\n    Mover[1].MoveToStation( Station[1] );\n    xMoveToHome     := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#movevelocity","title":"MoveVelocity","text":"<p>MoveVelocity( DesiredVelocity : LREAL )</p> <p>Chainable</p> <p>Executes a Velocity movement (with Collision Avoidance) at the specified Velocity. This command also implicitly updates the Mover's internal Velocity Motion Parameter.</p> <pre><code>IF xMoveVelocity THEN\n    Mover[1].MoveVelocity( 2000 );\n    xMoveVelocity   := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#reissuecommand","title":"ReissueCommand","text":"<p>ReissueCommand()</p> <p>Chainable</p> <p>Executes the latest command that was issued to the mover, e.g. a MoveToPosition command. The move is executed with the current internal Motion Parameters of the Mover, so the dynamics of the mover may not exactly match what was initially commanded. However, in cases of MoveToPosition or MoveToStation, the destination will be the same.</p> <p>To determine what type of movement ReissueCommand() will repeat, see Mover properties <code>CurrentMoveType</code>, <code>CurrentObjective</code>, and <code>CurrentDestinationPosition</code>.</p> <pre><code>// Issue a primary command\nIF xInitialCommand THEN\n    Mover[1].MotionParameters.Velocity  := 500; // mm/s\n    Mover[1].MoveToPosition( 1000 );\n    xInitialCommand     := FALSE;\n\n// Reissue the primary command, but with a new velocity parameter\nELSIF xUpdateCommand THEN\n    Mover[1].MotionParemeters.Velocity  := 750; // mm/s\n    Mover[1].ReissueCommand();\n    xUpdateCommand      := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#reset","title":"Reset","text":"<p>Reset()</p> <p>Chainable</p> <p>Calls a reset on the underlying axis immediately. The state machine unaffected and will, for example, keep the mover in the enabled state if .Reset() is called while is in the enable state.</p> <p>The mover's error properties will be cleared, and if and Axis error continues to exist after the reset, the error properties will continue to reflect this.</p>"},{"location":"CodeReference/Objects/Mover.html#setacceleration","title":"SetAcceleration","text":"<p>SetAcceleration( DesiredAccel : LREAL )</p> <p>Chainable</p> <p>Updates the Mover's internal Motion Parameter for Acceleration (mm/s\u00b2) and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xCommandHighAccel THEN\n    Mover[1].SetAcceleration( 2e4 );    // mm/s\u00b2\n    xCommandHighAccel       := FALSE;\nEND_IF\n</code></pre> <p>Notice</p> <p>This method implicitly calls .ReissueCommand() in the background in order for the updated dynamics to take effect immediately. If this is not the intent, consider modifying the Mover[x].MotionParameters property instead.</p>"},{"location":"CodeReference/Objects/Mover.html#setdeceleration","title":"SetDeceleration","text":"<p>SetDeceleration( DesiredDecel : LREAL )</p> <p>Chainable</p> <p>Updates the Mover's internal Motion Parameter for Deceleration (mm/s\u00b2) and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xCommandLowDecel THEN\n    Mover[1].SetDeceleration( 1e3 );    // mm/s\u00b2\n    xCommandLowDecel    := FALSE;\nEND_IF\n</code></pre> <p>Notice</p> <p>This method implicitly calls .ReissueCommand() in the background in order for the updated dynamics to take effect immediately. If this is not the intent, consider modifying the Mover[x].MotionParameters property instead.</p>"},{"location":"CodeReference/Objects/Mover.html#setdirection","title":"SetDirection","text":"<p>SetDirection( Direction : Tc3_Mc3Definitions.MC_Direction );</p> <p>Chainable</p> <p>Updates the Mover's internal Motion Parameter for Direction and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <p>Caution</p> <p>This method implicitly calls .ReissueCommand() in the background in order for the updated dynamics to take effect immediately. If this is not the intent, consider modifying the Mover[x].MotionParameters property instead. This method should only be used with care, and an understanding that a mover enroute can immediately reverse course and execute a motion command in the opposite direction when this method is called.</p> <pre><code>// For supported directions, see Infosys\n\nIF xReverseDirection THEN\n    Mover[1].SetDirection( mcDirectionPositive );\n    xReverseDirection   := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#setgap","title":"SetGap","text":"<p>SetGap( Gap : LREAL )</p> <p>Chainable</p> <p>Sets the collision avoidance gap for the specified mover in mm. This takes effect immediately.</p> <p>Caution</p> <p>This method can cause unexpected motion. If setting a larger gap for a mover that currently has movers within the new gap distance (on either side of the mover). Each affected mover will immediately attempt to adjust for the new gap which may result in movers moving forwards or backwards.</p> <p>When increasing the gap between movers it's recommended to do this one mover at a time only when the space in front of the mover is clear for at least the new gap distance. This can be accomplished with either a PositionTrigger or Zone.</p> <pre><code>Mover[1].SetGap( 65.0 );\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#setgapmode","title":"SetGapMode","text":"<p>SetGapMode( Mode : Tc3_Mc3Definitions.MC_GAP_CONTROL_MODE )</p> <p>Chainable</p> <p>Sets the collision avoidance gap control mode for the specified mover. This takes effect immediately.</p> <p>Default defers to the mode set in the NC's Collision Avoidance object.</p> <p>Note</p> <p>For modes other than Standard the NC's Collision Avoidance object must be set to <code>mcGapCtrlDirectionPositive</code>. This paramater can only be set in configuration and not during runtime.</p> Mode Description mcGapControlModeGroupDefault This value indicates that the GapControlMode set in the group parameters should be used for this motion command. mcGapControlModeStandard \"Caterpillar\" The axes fan out characteristically during the acceleration phase, such that a collision during the motion command is prevented. mcGapControlModeFast \"Lock-step\" All Axes move at the same time and with the full dynamics. mcGapControlModeNone This value indicates that the Gap Control is not active in the command. After the command, the Standby Gap Control takes effect again with the mode, which is set in the group and the gap size of the last valid command. <p>Additional documentation of gap control mode is available on Infosys which includes graphs comparing the options.</p> <pre><code>Mover[1].SetGapMode( mcGapControlModeStandard );\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#setjerk","title":"SetJerk","text":"<p>SetJerk( Jerk : LREAL )</p> <p>Chainable</p> <p>Updates the Mover's internal Motion Parameter for Jerk [mm/s3] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xUpdateJerk THEN\n    Mover[1].SetJerk( 1e5 );\n    xUpdateJerk     := FALSE;\nEND_IF\n</code></pre> <p>Notice</p> <p>This method implicitly calls .ReissueCommand() in the background in order for the updated dynamics to take effect immediately. If this is not the intent, consider modifying the Mover[x].MotionParameters property instead.</p>"},{"location":"CodeReference/Objects/Mover.html#setvelocity","title":"SetVelocity","text":"<p>SetVelocity( DesiredVelocity : LREAL )</p> <p>Chainable</p> <p>Updates the Mover's internal Motion Parameter for Velocity [mm/s] and immediately reissues any currently executing motion blocks so that the parameter update takes effect immediately</p> <pre><code>IF xCommandSlowMode THEN\n    Mover[1].SetVelocity( 500 );    // mm/s\n    xCommandSlowMode    := FALSE;\nEND_IF\n</code></pre> <p>Notice</p> <p>This method implicitly calls .ReissueCommand() in the background in order for the updated dynamics to take effect immediately. If this is not the intent, consider modifying the Mover[x].MotionParameters property instead.</p>"},{"location":"CodeReference/Objects/Mover.html#synctoaxis","title":"SyncToAxis","text":"<p>SyncToAxis( MasterAxis : AXIS_REFERENCE, MasterSyncPos : LREAL, SlaveSyncPos : LREAL, SyncStrategy : MC_SYNC_STRATEGY )</p> <p>Chainable</p> <p>Pairs the current mover with an external axis (real or virtual) with specified Master &amp; Slave Sync Positions. The current mover will synchronize according to the parameter SyncStrategy and a 1:1 gear ratio. The synchronization can be ended by executing a call on the slave for any other motion command, e.g. <code>MoveToPosition</code> or <code>Halt</code>.</p> <p>MasterAxis is a reference to the NC axis object that the mover should synchronize with, real or virtual.</p> <p>MasterSyncPos is the position of the Master at which point the mover will be InSync and will have the correct gear ratio (1:1).</p> <p>SlaveSyncPos is the position of the mover at which point it is InSync</p> <p>SyncStrategy defines the type of calculation used to blend the movements and establish the synchronization. Simply put, the mover should synchronize immediately &amp; aggressively, as late as possible and aggressively, or as gently as possible.</p> <p>For more information on these inputs, see InfoSys documentation for the underlying MC_GearInPosCA Function Block</p> <p>See also: Mover.IsSyncedToAxis</p> <pre><code>IF xCmdSyncToAxis THEN\n    xCmdSyncToAxis  := FALSE;\n    MasterSyncPos   := ConveyorAxis.NcToPlc.ActPos + 400;\n    Mover[1].SyncToAxis( ConveyorAxis, MasterSyncPos, 1500, mcSyncStrategyEarly );\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#synctomover","title":"SyncToMover","text":"<p>SyncToMover( MasterMover : Mover, Gap : LREAL )</p> <p>Chainable</p> <p>Pairs the current mover with a desired mover at a specified gap distance. The current mover will immediately move (with CA) to a specified distance from the Master Mover and then mimic all motion from the master. The synchronization can be ended by executing a call on the slave for any other motion command, e.g. <code>MoveToPosition</code> or <code>Halt</code>.</p> <p>Gap specifies a center-to-center following distance between master and slave movers. This gap cannot be achieved if it is below the minimum collision avoidance distance established in the CA group. Positive Gap values will result in a following position behind the master and negative values will result in a slave that precedes the master.</p> <p>Additional calls to this method can be used to update the gap between paired movers.</p> <p>See also: Mover.IsSyncedToMover and Mover.MasterMover</p> <pre><code>IF xCmdSyncToLeader THEN\n    Mover[1].SyncToMover( Mover[1], 100 );  // move 100mm away from Mover 1\n\n    IF Mover[1].IsSyncedToMover THEN\n        Mover[2].MoveToPosition( 2000 );    // Master moves to 2000 and Mover 0 will follow\n    END_IF;\nEND_IF;\n</code></pre> <pre><code>IF xBuildTrain THEN\n    Mover[4].SyncToMover( Mover[4], 100 );\n    Mover[3].SyncToMover( Mover[4], 200 );\n    Mover[2].SyncToMover( Mover[4], 300 );\n    Mover[1].SyncToMover( Mover[4], 400 );\n\n    IF Mover[1].IsSyncedToMover THEN\n        // Commands Mover 4 to move ahead at 300 mm/s\n        Mover[1].MasterMover.MoveVelocity( 300 );\n    END_IF;\nEND_IF;     \n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#unregisterfromall","title":"UnregisterFromAll","text":"<p>UnregisterFromAll()</p> <p>Unregisters a mover from all Mover Lists, Position Triggers, Station and Zones.</p>"},{"location":"CodeReference/Objects/Mover.html#validatetrack","title":"ValidateTrack","text":"<p>ValidateTrack()</p> <p>Confirms that a valid track is selected and returns true. Otherwise logs an error and returns false to be handled by higher-level code.</p> <p>This method is typically used internally by other motion methods of movers to log an error message when a command is issued to a mover who is not on a valid track. The property .IsTrackReady is intended for use in user code.</p>"},{"location":"CodeReference/Objects/Mover.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/Mover.html#currentdestinationposition","title":".CurrentDestinationPosition","text":"<p>LREAL</p> <p>Provides the current destination position for the last movement command issued to the Mover. For Station commands, this will be the Position of the Station. For Velocity commands with no real destination position, the value is set to +/-1E300.</p>"},{"location":"CodeReference/Objects/Mover.html#currentdestinationtrack","title":".CurrentDestinationTrack","text":"<p>DINT</p> <p>Provides the current destination track for the last movement command issued to the Mover. When track management is used, it should be queried along with the property .CurrentDestinationPosition to validate destinations.</p>"},{"location":"CodeReference/Objects/Mover.html#currentmovetype","title":".CurrentMoveType","text":"<p>MoverCommandType_enum</p> <pre><code>MOVETYPE_NONE           // this mover was just enabled and has no movement history\nMOVETYPE_POSITION       // this mover was most recently issued a MoveToPosition command\nMOVETYPE_STATION        // this mover was most recently issued a MoveToStation command\nMOVETYPE_VELOCITY       // this mover was most recently issued a MoveVelocity command\n</code></pre> <p>Provides the current (last executed) type of movement command issued to the Mover</p>"},{"location":"CodeReference/Objects/Mover.html#currentobjective","title":".CurrentObjective","text":"<p>STRING</p> <p>Provides the current Objective destination for the Mover. Right now this is only valid when the Mover is destined for a Station objective, and provides a string name for that station.</p>"},{"location":"CodeReference/Objects/Mover.html#currenttrack","title":".CurrentTrack","text":"<p>POINTER TO Track</p> <p>Returns a pointer to the track that this mover is currently assigned to.</p> <p>Use the ^ operator to dereference the pointer and query track properties</p> <pre><code>currentTrackId := Mover[1].CurrentTrack^.Id\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#iscollisionavoidanceactive","title":".IsCollisionAvoidanceActive","text":"<p>BOOL</p> <p>Returns true if collision avoidance is affecting the desired motion profile of this mover</p> <pre><code>IF Mover[1].IsCollisionAvoidanceActive THEN\n    // additional commands\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#iserrormover","title":".IsErrorMover","text":"<p>BOOL</p> <p>Returns TRUE if the current Mover reference is an Error Mover. An Error mover is automatically returned when an invalid command is given to an interface capable of returning a Mover. See Diagnostics / ErrorMovers for more information.  </p> <pre><code>//Returns an ErrorMover as the GetMover function works on an 1 based Index\n\nMoverReference REF= Zone[0].GetMover(0,MC_Direction.MC_Positive_Direction);\nIF NOT MoverReference.IsErrorMover THEN\n    // Will not execute as the MoverReference is an error mover.\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#issyncedtoaxis","title":".IsSyncedToAxis","text":"<p>BOOL</p> <p>Returns true if the mover is slaved to an external axis and has successfully reached the following position specified by the Master &amp; Slave Sync Positions</p>"},{"location":"CodeReference/Objects/Mover.html#issyncedtomover","title":".IsSyncedToMover","text":"<p>BOOL</p> <p>Returns true if the mover is slaved to another mover and has successfully reached the following position specified by the Gap.</p>"},{"location":"CodeReference/Objects/Mover.html#istrackready","title":".IsTrackReady","text":"<p>BOOL</p> <p>Returns true when the ActivateTrack() method has completed successfully. When using track management motion commands should not be issued unless this value is true or the mover will throw an error.</p> <p>When using track management it can take several PLC scans for the .ActivateTrack method to complete. It is advised to wait for this to return after issuing an .ActivateTrack() command to avoid motion errors.</p>"},{"location":"CodeReference/Objects/Mover.html#mastermover","title":".MasterMover","text":"<p>REFERENCE To Mover</p> <p>Reference variable that refers to the Mover this Mover is currently slaved to</p> <p>When this mover is not slaved to another mover, .MasterMover is an invalid reference. There is therefore an ErrorMover object which will return information on what action was requested by the object while .MasterMover was invalid. This will show up in TwinCAT's Event Logs. See Diagnostics / ErrorMovers for more information.  </p> <p>It is recommended that all evaluations are nested inside IF checks for .IsSyncedToMover OR by calling __ISVALIDREF</p>"},{"location":"CodeReference/Objects/Mover.html#moverindex","title":".MoverIndex","text":"<p>UDINT</p> <p>Unique, sequential mover identification number. The index matches the index of the array XTS.Mover[]</p> <p>The mover index is assigned at startup after the mover 1 search is complete. The order of movers is determined by the Mover 1 search properties configured in the XTS TcCOM object. When Mover 1 is present .MoverIndex will be persistent between cold-starts of the system. If Mover 1 is not used, .MoverIndex will not be persistent between cold-starts of the system.</p>"},{"location":"CodeReference/Objects/Mover.html#motionparameters","title":".MotionParameters","text":"<p>MotionParameters_typ</p> <p>Defines a structure containing the dynamics settings for the Mover. Any new motion commands issued will utilize these values.</p> <p>Note</p> <p>Despite listing this value as a Property here in the documentation, MotionParameters are actually defined as a regular Input to the Mover object. This allows component access to the members of the STRUCT, which is not possible for Properties.</p> <pre><code>STRUCT\n    Jerk         : LREAL;                           // mm/s\u00b3\n    Acceleration : LREAL;                           // mm/s\u00b2\n    Deceleration : LREAL;                           // mm/s\u00b2\n    Velocity     : LREAL;                           // mm/s\n    Direction    : Tc3_Mc3Definitions.MC_Direction; // MC_Direction\n    Gap          : LREAL;                           // mm\n    GapMode      : MC_GAP_CONTROL_MODE := MC_GAP_CONTROL_MODE.mcGapControlModeGroupDefault; // default to mode defined in collision avoidance object\nEND_STRUCT\n</code></pre> <p>Modifying a mover's Motion Parameters will not affect the current dynamics of a mover enroute. Updated dynamics properties will only take effect when the next motion command is issued.</p> <p>It is also possible to alter motion paramaters with mover methods such as <code>.SetVelocity()</code>, <code>.SetAcceleration()</code> and others. These methods implicitly call .ReissueCommand() and therefore take effect immediately.</p>"},{"location":"CodeReference/Objects/Mover.html#nextmover","title":".NextMover","text":"<p>Returns the next mover in line with respect to this mover. Specifically, it returns the closest mover with a greater Position value than the current mover, regardless of actual direction of travel.</p>"},{"location":"CodeReference/Objects/Mover.html#payload","title":".Payload","text":"<p>Data associated with the product on the mover.</p> <p>The code uses a structure with some example data that may be relevant to an in-process part on the mover. The structure is located in the PLC Project &gt; DUTs &gt; MoverPayload_typ.</p> <pre><code>TYPE MoverPayload_typ :\nSTRUCT\n    // data related to the in-process part on the mover\n    // can be modifited to suit the application\n    RecipeId        : DINT;\n    FailureReason   : DINT;\n    SerialNumber    : STRING;\nEND_STRUCT\nEND_TYPE\n</code></pre> <p>This data travels with the mover and when a mover arrives at a station it can be queried or modified based on the station's process. This structure can be modified as needed to suit the application.</p> <p>Note that because .Payload is a property that returns a structure an intermediate variable must be used for access as shown in the examples below.</p> <pre><code>// query the recipe ID and react accordingly\nVAR\n    MoverPayload : MoverPayload_typ;\nEND_VAR\n\nIF (Station[1].MoverInPosition) THEN\n    // get the payload\n    MoverPayload := Station[1].CurrentMover.Payload;\n    // query the payload\n    IF MoverPayload.RecipeID = 1 THEN\n        // add recipe 1 specific code here\n    ELSE\n        // add code specific to other recipes here\n    END_IF;\nEND_IF;\n</code></pre> <pre><code>// Store a serial number for the part on the mover from a scanned barcode\nVAR\n    MoverPayload : MoverPayload_typ;\nEND_VAR\n\nIF (ScanComplete) THEN\n    // get the payload\n    MoverPayload := Station[1].CurrentMover.Payload;\n    // store data to the payload, then the mover\n    MoverPayload.SerialNumber := ScannedBarcode;\n    Station[1].CurrentMover.Payload := MoverPayload;\n    // send mover to next station\n    Station[1].CurrentMover.MoveToStation(Station[2]);\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/Mover.html#previousmover","title":".PreviousMover","text":"<p>Returns the previous mover in line with respect to this mover. Specifically, it returns the closest mover with a lesser Position value than the current mover, regardless of actual direction of travel.</p>"},{"location":"CodeReference/Objects/Mover.html#trackinfo","title":".TrackInfo","text":"<p>Returns information provided by MC_ReadTrackPositions for use with track management.</p> <p>Note</p> <p>Despite listing this value as a Property here in the documentation, TrackInfo is actually defined as a regular Output from the Mover object. This allows component access to the members of the STRUCT, which is not possible for Properties.</p> Member Type Description TrackId OTCID The hardware ID of the track the mover is assigned to PartId OTCID The hardware ID of the part the mover is physically present on TrackPosition LREAL Position of the mover measured from the zero point of the track. This may differ from Mover.AxisReference.NcToPLC.ActPos in certain track configurations PartPosition LREAL Position of the mover measured from the zero point of the part the mover is physically on"},{"location":"CodeReference/Objects/MoverList.html","title":"Mover List Object","text":"<p>The Mover List object provides a way to group Movers together and issue commands to every Mover in the list. Alternatively, commands can be sent to individual movers within the list based on their geographic proximity to a track position.</p> <p>Many of the methods and properties below are group commands based on corresponding methods available and documented in the singular Mover object.</p>"},{"location":"CodeReference/Objects/MoverList.html#setup-execution","title":"Setup &amp; Execution","text":"<pre><code>// Declaration\nMoverListA      : MoverList;\n</code></pre> <pre><code>// Usage\nMoverListA.RegisterMover( Mover[1] );\nMoverListA.RegisterMover( Mover[2] );\nMoverListA.RegisterMover( Mover[3] );\n\nMoverListA.SetAllVelocity( 1000 );\nMoverListA.MoveAllToStation( Station[4] );\n\nMoverListA.UnregisterAll();\n</code></pre> <p>MoverLists must also be added to the Mediator object. By default, this is handled already in the MAIN.Initialize ACTION.</p> <pre><code>// Example implementation\nMediator.AddMoverList( MoverListA );\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#chainability-and-related-objects","title":"Chainability and related objects","text":"<p>The <code>Track</code> and <code>Zone</code> objects keep internal mover lists that can be accessed with the <code>.CurrentMoverList</code> property. And many of the methods below return mover lists.</p> <p>Additionally a mover list is extended from <code>Objective</code> which provides two additional and very helpful properties <code>.TrackedMoverCount</code> and <code>.TrackedMovers</code>.</p> <p>The combination of these functionalities can allow for powerful and concise handling of movers throughout the system. Some examples follow.</p> <p><pre><code>// find all movers on track 2 with a destination station of 3 and redirect them to station 4\nTrack[2].CurrentMoverList.FilterDestinationStation(Station[3]).MoveAllToStation(Station[4]);\n</code></pre> <pre><code>// count the number of movers in Zone 2 and Zone 3\nMoverCount := Zone[2].CurrentMoverList.LogicalIntersect(Zone[3].CurrentMoverList).TrackedMoverCount;\n</code></pre></p>"},{"location":"CodeReference/Objects/MoverList.html#methods","title":"Methods","text":""},{"location":"CodeReference/Objects/MoverList.html#activatealltrack","title":"ActivateAllTrack","text":"<p>ActivateAllTrack( Track: Track)</p> <p>Issues individual ActivateTrack commands to every mover registered with the list.</p> <p>The property IsAllTrackReady can be used to query for the completion of this method. Note that ActivateAllTrack and IsAllTrackReady may need to operate on different lists when working with Zone and Track lists as both Zone and Track are track-aware and only return movers that are both assigned to the track that the track or zone is also assigned to.</p> <p>See Mover.ActivateTrack and for additional notes about track management.</p> <pre><code>// state machine\n100:\n    Track[1].CurrentMoverList.ActivateAllTrack(Track[2]);\n    // check track 2 for command completeness as the movers are being reassigned to this track\n    IF (Track[2].CurrentMoverList.IsAllTrackReady) THEN\n        iState := 200;\n    END_IF;\n\n200:\n    // movers on track 2 ready for commands\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#applyallparameterset","title":"ApplyAllParameterSet","text":"<p>ApplyAllParameterSet( ParameterSet : MotionParameters_typ )</p> <p>Applies a set of motion paramaters to then entire mover list.</p> <p>This only sets the motion parameters that will be used for the next motion command. Any in process motion will not be affected by this method. To immediately change motion paramaters use methods such as <code>.SetAllVelocity</code> or <code>.SetAllAcceleration</code>.</p>"},{"location":"CodeReference/Objects/MoverList.html#contains","title":"Contains","text":"<p>Contains( Mover: Mover )</p> <p>Returns TRUE if the MoverList already contains the input Mover</p> <pre><code>IF MoverListA.Contains( Mover[4] ) THEN\n    // Yes, Mover 4 must exist in MoverListA\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#filterdestinationstation","title":"FilterDestinationStation","text":"<p>FilterDestinationStation( Destination : REFERENCE TO Station ) : MoverList</p> <p>Filters the mover list to only include movers that have a destination that matches the parameter Destination.</p> <p>Filtering a mover list by station can be helpful when workings with several movers in a zone. There are two typical use cases. The first is to avoid re-triggering a move to station command after code such as <code>Zone[1].CurrentMoverList.MoveAllToStation(Station[2])</code> has executed, but movers are still accelerating out of this zone. The second is to ignore movers that may have a non-typical destination such as a rejected part in an otherwise normal flow of good parts.</p>"},{"location":"CodeReference/Objects/MoverList.html#disableall","title":"DisableAll","text":"<p>DisableAll()</p> <p>Calls the Disable() method for all movers in the list.</p>"},{"location":"CodeReference/Objects/MoverList.html#enableall","title":"EnableAll","text":"<p>Calls the Enable() method for all movers in the list.</p>"},{"location":"CodeReference/Objects/MoverList.html#getmoverbylocation","title":"GetMoverByLocation","text":"<p>GetMoverByLocation( Index : USINT, Position : LREAL, Direction : Tc2_MC2.MC_Direction ) : REFERENCE TO Mover</p> <p>Returns a reference to a singular mover from the Mover List, based on it's geographic location relative to a fixed track position.</p> <p>Index specifies the number of movers that should lie between the selection and the Position input. Therefore Index = 1 would be the closest mover to the input position (in a given direction), Index = 2 would be the second closest, Index = 3 would be the third closest, etc.</p> <p>Position specifies the target around which mover proximity should be considered.</p> <p>Direction specifies the direction around the track from which the movers are indexed. Therefore MC_Positive_Direction will begin returning movers with the most positive absolute position values that are still less than the position input. In linear, non-closed tracks MC_Shortest_Way can be used to find movers in both directions using the absolute value of the difference between the fixed Position and the mover position.</p> <pre><code>// Select a mover in the MoverList\n// Which is the first closest mover to position 900\n// And which has a position less than 900\n// Then sends it to a station\nMoverListA.GetMoverByLocation( 1, 900, MC_Positive_Direction ).MoveToStation( Station[3] );\n\n// Select a mover in the MoverList\n// Which is the third closest mover to position 2000\n// And which has a position greater than 3000\n// Then sets its acceleration\nMoverListA.GetMoverByLocation( 3, 3000, MC_Negative_Direction ).SetAcceleration( 1E4 );\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#halt-all","title":"Halt All","text":"<p>HaltAll()</p> <p>Calls the Halt() method for all movers in the list.</p>"},{"location":"CodeReference/Objects/MoverList.html#logicalcomplement","title":"LogicalComplement","text":"<p>LogicalComplement()</p> <p>Returns the logical complement of the current MoverList. Thus the returned list will list all movers not in the current MoverList.</p> <pre><code>// System contains: M1, M2, M3, M4, M5\n// MoverListA =     M1, M2, M3\nMoverListA.LogicalCompliment(); // returns: M4, M5\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#logicaldifference","title":"LogicalDifference","text":"<p>LogicalDifference( MoverList : MoverList )</p> <p>Returns the logical difference of the current MoverList and the provided MoverList. Thus the returned list will list all movers in the current MoverList (MoverListA) and not in the provided MoverList (MoverListB).</p> <pre><code>// MoverListA = M1, M2, M3\n// MoverListB =         M3, M4, M5\nMoverListA.LogicalDifference( MoverListB ); // returns: M1, M2\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#logicalintersect","title":"LogicalIntersect","text":"<p>LogicalIntersect( MoverList : MoverList )</p> <p>Returns the logical intersection of the current MoverList and the provided MoverList. Thus the returned list will list all movers in the current MoverList (MoverListA) that are also in the provided MoverList (MoverListB).</p> <pre><code>// MoverListA = M1, M2, M3\n// MoverListB =         M3, M4, M5\nMoverListA.LogicalIntersect( MoverListB ); // returns: M3\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#logicalunion","title":"LogicalUnion","text":"<p>LogicalUnion( MoverList : MoverList )</p> <p>Returns the logical union of the current MoverList and the provided MoverList. Thus the returned list will list all movers in the current MoverList (MoverListA) and in the provided MoverList (MoverListB) deduplicated.</p> <pre><code>// MoverListA = M1, M2, M3\n// MoverListB =         M3, M5\nMoverListA.LogicalUnion( MoverListB ); // returns: M1, M2, M3, M5\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#movealltoposition","title":"MoveAllToPosition","text":"<p>MoveAllToPosition( DestinationPosition : LREAL )</p> <p>Issues individual MoveToPosition commands to every mover registered with the list.</p> <pre><code>MoverListA.MoveAllToPosition( 1200 );\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#movealltostation","title":"MoveAllToStation","text":"<p>MoveAllToStation( DestinationStation: Station )</p> <p>Issues individual MoveToStation commands to every mover registered with the list.</p> <pre><code>MoverListA.MoveAllToStation( Station[3] );\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#moveallvelocity","title":"MoveAllVelocity","text":"<p>MoveAllVelocity( DesiredVelocity : LREAL )</p> <p>Issues individual MoveVelocity commands to every mover registered with the list.</p> <pre><code>MoverListA.MoveAllVelocity( 300 );\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#setallacceleration","title":"SetAllAcceleration","text":"<p>SetAllAcceleration( DesiredAcceleration : LREAL )</p> <p>Sets the acceleration motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllAcceleration( 1E3 );\n</code></pre> <p>Note</p> <p>This method causes new motion commands to be issued for the dynamics to take effect immediately- potentially triggering a large number of motion commands to execute on the same scan. See the individual Mover command and consider the ramifications for your application.</p>"},{"location":"CodeReference/Objects/MoverList.html#setalldeceleration","title":"SetAllDeceleration","text":"<p>SetAllDeceleration( DesiredDeceleration : LREAL )</p> <p>Sets the deceleration motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllDeceleration( 15000 );\n</code></pre> <p>Note</p> <p>This method causes new motion commands to be issued for the dynamics to take effect immediately- potentially triggering a large number of motion commands to execute on the same scan. See the individual Mover command and consider the ramifications for your application.</p>"},{"location":"CodeReference/Objects/MoverList.html#setalldirection","title":"SetAllDirection","text":"<p>SetAllDirection( Direction : Tc3_Mc3Definitions.MC_DIRECTION )</p> <p>Sets the direction motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllDirection( mcDirectionPositive );\n</code></pre> <p>Note</p> <p>This method causes new motion commands to be issued for the dynamics to take effect immediately- potentially triggering a large number of motion commands to execute on the same scan. See the individual Mover command and consider the ramifications for your application.</p>"},{"location":"CodeReference/Objects/MoverList.html#setallgap","title":"SetAllGap","text":"<p>SetAllGap( Gap : LREAL )</p> <p>Sets the gap for every mover in the list</p> <pre><code>MoverListA.Gap( 65.0 );\n</code></pre> <p>Note</p> <p>This method causes new motion commands to be issued for the dynamics to take effect immediately- potentially triggering a large number of motion commands to execute on the same scan. See the individual Mover command and consider the ramifications for your application.</p>"},{"location":"CodeReference/Objects/MoverList.html#setallgapmode","title":"SetAllGapMode","text":"<p>SetAllGapMode( Mode : Tc3_Mc3Definitions.MC_GAP_CONTROL_MODE )</p> <p>Sets the gap mode for every mover in the list</p> <pre><code>MoverListA.SetAllGapMode( mcGapControlModeStandard );\n</code></pre> <p>Note</p> <p>This method causes new motion commands to be issued for the dynamics to take effect immediately- potentially triggering a large number of motion commands to execute on the same scan. See the individual Mover command and consider the ramifications for your application.</p>"},{"location":"CodeReference/Objects/MoverList.html#setalljerk","title":"SetAllJerk","text":"<p>SetAllJerk( DesiredJerk : LREAL )</p> <p>Sets the jerk motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllJerk( 1e5 );\n</code></pre> <p>Note</p> <p>This method causes new motion commands to be issued for the dynamics to take effect immediately- potentially triggering a large number of motion commands to execute on the same scan. See the individual Mover command and consider the ramifications for your application.</p>"},{"location":"CodeReference/Objects/MoverList.html#setallvelocity","title":"SetAllVelocity","text":"<p>SetAllVelocity( DesiredVelocity : LREAL )</p> <p>Sets the velocity motion parameter equal to the input argument for every mover in the list</p> <pre><code>MoverListA.SetAllVelocity( 2000 );\n</code></pre> <p>Note</p> <p>This method causes new motion commands to be issued for the dynamics to take effect immediately- potentially triggering a large number of motion commands to execute on the same scan. See the individual Mover command and consider the ramifications for your application.</p>"},{"location":"CodeReference/Objects/MoverList.html#unregisterall","title":"UnregisterAll","text":"<p>UnregisterAll()</p> <p>Unregisters every mover from the list immediately</p> <pre><code>MoverListA.UnregisterAll();\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/MoverList.html#isallmoversdisabled","title":".IsAllMoversDisabled","text":"<p>BOOL</p> <p>Queries all movers registered with the mover list for the their <code>.Ready</code> property and returns true if all movers are not ready.</p> <pre><code>// state machine\n    100:\n        // disable movers\n        MoverList[1].DisableAll();\n        state := 200;\n    200:\n        // wait for all movers to be disabled\n        IF (MoverList[1].AllMoversDisabled) THEN\n            state := 300;\n        END_IF;\n    300:\n        // movers are disabled\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#isallmovershalted","title":".IsAllMoversHalted","text":"<p>BOOL</p> <p>Queries all movers registered with the mover list for their <code>.Moving</code> property and returns true if all movers are not moving</p> <pre><code>    // state machine\n        100:\n            // halt all movers in zone 1\n            Zone[1].CurrentMoverList.HaltAll();\n            state := 200;\n        200:\n            // wait for all movers to be stopped\n            IF (Zone[1].CurrentMoverList.AllMoversHalted) THEN\n                state := 300;\n            END_IF;\n        300:\n            // movers in zone 1 are stopped\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#isallmoversready","title":".IsAllMoversReady","text":"<p>BOOL</p> <p>Queries all movers registered with the mover list for their <code>.Ready</code> property and returns true if all mover are ready.</p> <pre><code>// state machine\n    100:\n        // enable movers\n        MoverList[1].EnableAll();\n        state := 200;\n    200:\n        // wait for all movers to be ready\n        IF (MoverList[1].AllMoversReady) THEN\n            state := 300;\n        END_IF;\n    300:\n        // movers are enable and ready for motion commands\n</code></pre>"},{"location":"CodeReference/Objects/MoverList.html#isalltrackready","title":".IsAllTrackReady","text":"<p>BOOL</p> <p>Queries all movers registered with the mover list for their IsTrackReady property and returns true when all movers have this property set true.</p> <p>Note: This routine intentionally returns false if no movers are on the track. This is to handle the several scan delay between activating a track and the mover reporting the track is active. In a typical use case .ActivateAllTrack and .IsAllTrackReady are called back to back. Without this exception code folling .IsAllTrackReady would falsely assume the track switch is complete if the track was empty causing mover motion commands to throw errors.</p> <p>See ActivateAllTrack() for an example.</p>"},{"location":"CodeReference/Objects/MoverList.html#trackedmovercount","title":".TrackedMoverCount","text":"<p>USINT</p> <p>Note</p> <p>This property is part of Objective but is frequently used with mover lists and can be accessed as part of the MoverList object.</p>"},{"location":"CodeReference/Objects/MoverList.html#trackedmovers","title":".TrackedMovers","text":"<p>ARRAY OF POINTER TO Mover</p> <p>Note</p> <p>This property is part of Objective but is frequently used with mover lists and can be accessed as part of the mover list.</p>"},{"location":"CodeReference/Objects/Objective.html","title":"Objectives","text":"<p>Objective is an ABSTRACT base class used by the project, whose child objects include the following:</p> <ul> <li>Stations</li> <li>Zones</li> <li>PositionTriggers</li> <li>MoverLists</li> <li>Tracks</li> </ul> <p>Each Objective defines a set criteria that a Mover can either fulfill or not at any given point. As an example, a Mover fulfills the criteria of a Station when it is parked at the Station's configured track position.</p> <p>When a Mover satisfies the requirements of the Objective, the Objective provides a Reference to the Mover through which new Mover commands can be issued.</p>"},{"location":"CodeReference/Objects/Objective.html#common-methods","title":"Common Methods","text":"<p>The objects listed above all share some common methods, which are implemented in the parent Objective base class.</p>"},{"location":"CodeReference/Objects/Objective.html#registermover","title":"RegisterMover","text":"<p>RegisterMover( NewMover : Mover )</p> <p>Adds a Mover to the list of Tracked Movers that the objective is currently monitoring. If the input Mover has already been added to the Tracked Movers list, the method call is ignored.</p> <pre><code>Mover[1].MoveToPosition( Station[1].Position );\nStation[1].RegisterMover( Mover[1] );\n</code></pre> <p>The code above is similar in functionality to:</p> <pre><code>Mover[1].MoveToStation( Station[1] );\n</code></pre> <p>Stations include some unique features regarding mover registration. See Station Object for more details.</p>"},{"location":"CodeReference/Objects/Objective.html#registermoverlist","title":"RegisterMoverList","text":"<p>RegisterMoverList( NewMoverList : MoverList )</p> <p>Provides the same functionality as RegisterMover, but for a group of movers represented as a MoverList.</p> <pre><code>MoverListA.RegisterMoverList(MoverListB);\n</code></pre>"},{"location":"CodeReference/Objects/Objective.html#unregistermover","title":"UnregisterMover","text":"<p>RegisterMover( ExistingMover : Mover )</p> <p>Removes a Mover from the list of Tracked Movers that the objective is currently monitoring. If the input Mover is not already tracked by the objective, the method call is ignored.</p> <pre><code>Mover[1].MoveToStation( Station[1] );\nStation[1].UnregisterMover( Mover[1] );\n</code></pre> <p>Because the Mover would not be registered with the Station when it arrives, the Station would not report that the Mover is InPosition. The code above is functionally identical to:</p> <pre><code>Mover[1].MoveToPosition( Station[1].Position );\n</code></pre>"},{"location":"CodeReference/Objects/Objective.html#unregistercurrent","title":"UnregisterCurrent","text":"<p>UnregisterCurrent( )</p> <p>Automatically unregisters whatever mover is listed as CurrentMover for the Objective</p> <p>Here the MoverInPosition status output changes. The mover is still physically located at the Station position, but since it is no longer registered, it cannot report MoverInPosition.</p> <p><pre><code>bCheck  := Station[1].MoverInPosition;  // returns TRUE\nStation[1].UnregisterCurrent();\nbCheck  := Station[1].MoverInPosition;  // returns FALSE\n</code></pre> Position triggers use <code>UnregisterCurrent</code> to indicate to the trigger that any processing that needs to be done with this mover has been completed.</p> <pre><code>IF PositionTrigger[1].MoverPassedPosition THEN\n    PositionTrigger[1].CurrentMover.SetVelocity( 200 );\n    PositionTrigger[1].UnregisterCurrent();\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Objective.html#unregisterall","title":"UnregisterAll","text":"<p>UnregisterAll()</p> <p>Automatically unregisters every mover from the Tracked Movers list</p> <pre><code>IF xClearTrigger THEN\n    PositionTrigger[2].UnregisterAll();\n    xClearTrigger   := FALSE;\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Objective.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/Objective.html#currentmover","title":"CurrentMover","text":"<p>REFERENCE TO Mover</p> <p>Current mover is the Reference output through which Movers can be addressed contextually via an Objective. Let's look at a simple example:</p> <pre><code>Station[3].CurrentMover;    // is equivalent to...\nMover[4];                   // as long as Mover #4 is parked at Station#3\n</code></pre> <p>And as a Reference, this CurrentMover output accepts any Method call instructions that a base Mover object could. E.g.:</p> <pre><code>Station[3].CurrentMover.SetVelocity( 2000 );    // is equivalent to...\nMover[4].SetVelocity( 2000 );   // so long as the the Mover is parked as above\n</code></pre>"},{"location":"CodeReference/Objects/Objective.html#trackedmovercount","title":"TrackedMoverCount","text":"<p>USINT</p> <p>Returns the number of movers being tracked by this objective.</p>"},{"location":"CodeReference/Objects/Objective.html#trackedmovers","title":"TrackedMovers","text":"<p>ARRAY OF POINTER TO Mover</p> <p>Returns an array of pointers to all the movers tracked by this object.</p> <p>Note that this returns a pointer. To access properties or methods of a mover the pointer must be dereferenced with the <code>^</code> (caret) operator such as <code>Objective.TrackedMovers[0]^.TrackInfo.TrackPosition</code>.</p>"},{"location":"CodeReference/Objects/PositionTrigger.html","title":"Position Trigger Object","text":"<p>Position Trigger objects monitor movers until they have crossed over a specified location on track, even if they do not stop there. Position Triggers will always point to the most recent registered mover which crossed over the Position Trigger's track position. When using track management the position trigger will only trigger if the mover crosses the specificed location and has a matching TrackId.</p>"},{"location":"CodeReference/Objects/PositionTrigger.html#setup-execution","title":"Setup &amp; Execution","text":""},{"location":"CodeReference/Objects/PositionTrigger.html#setup","title":"Setup","text":"<pre><code>// Declaration\nPositionTriggerA        : PositionTrigger;\n</code></pre> <pre><code>// Initialization\nPositionTriggerA.Position       := 2000;\nPositionTriggerA.TriggerDirection   := mcDirectionPositive;\n</code></pre>"},{"location":"CodeReference/Objects/PositionTrigger.html#execution","title":"Execution","text":"<p>A position trigger must be checked each scan for movers that have crossed it's position. Then the mover must be acknowledged before another mover can be detected at this position.</p> <pre><code>// test for mover crossing this position trigger\nIF (PositionTriggerA.MoverPassedPosition) THEN\n    // get the most recent mover and change it's velocity\n    PositionTriggerA.CurrentMover.SetVelocity(500);\n    // acknowledge the mover calling the MuteCurrent method\n    // this re-arms the position trigger for the next mover\n    PositionTriggerA.MuteCurrent();\nEND_IF;\n</code></pre>"},{"location":"CodeReference/Objects/PositionTrigger.html#usage-notes","title":"Usage notes","text":"<p>Position Triggers must also be added to the Mediator object. By default, this is handled already in the MAIN.Initialize ACTION.</p> <pre><code>// Example implementation\nMediator.AddPositionTrigger( PositionTriggerA );\n</code></pre>"},{"location":"CodeReference/Objects/PositionTrigger.html#methods","title":"Methods","text":""},{"location":"CodeReference/Objects/PositionTrigger.html#cyclic","title":"Cyclic","text":"<p>Cyclic()</p> <p>Position Triggers require a cyclic call in the Main Program because they need to constantly monitor the positions of registered movers.</p> <p>This is automatically called by the Mediator when using the pre-defined position triggers in MAIN.</p>"},{"location":"CodeReference/Objects/PositionTrigger.html#mutecurrent","title":"MuteCurrent","text":"<p>MuteCurrent()</p> <p>Clears a Mover reference from the CurrentMover property, and resets MoverPassedPosition to be false. This can be done without the need to unregister a mover from a position trigger</p> <p>Since Position Triggers uniquely latch their CurrentMover output, it is necessary to clear this value manually in order to prepare to process the next mover event.</p> <pre><code>IF PositionTrigger[0].MoverPassedPosition THEN\n    PositionTrigger[0].CurrentMover.MoveVelocity( 200 );\n    PositionTrigger[0].MuteCurrent();\nEND_IF\n</code></pre> <p>In this way, it is possible to reset the position trigger without having to completely unregister and re-register a mover from the trigger.</p> <p>This method will produce a Log Event to aid in troubleshooting.</p>"},{"location":"CodeReference/Objects/PositionTrigger.html#reset-statistics","title":"Reset Statistics","text":"<p>ResetStatistics()</p> <p>Resets the Statistics for this station. See the Statistics property.</p>"},{"location":"CodeReference/Objects/PositionTrigger.html#set-track","title":"Set track","text":"<p>SetTrack()</p> <pre><code>PositionTrigger[1].Position := 1000.0;\nPositionTrigger[1].SetTrack(Track[2]);\n</code></pre>"},{"location":"CodeReference/Objects/PositionTrigger.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/PositionTrigger.html#moverpassedposition","title":".MoverPassedPosition","text":"<p>BOOL</p> <p>Status boolean indicating that at least one mover has passed over the threshold position since being registered</p> <p>Position Triggers are unique in that the Current Mover output latches even though the mover may not still qualify under the trigger condition</p>"},{"location":"CodeReference/Objects/PositionTrigger.html#currentmover","title":".CurrentMover","text":"<p>REFERENCE TO Mover</p> <p>Reference variable that refers to the most recent registered mover to cross over the track position since being registered</p> <ul> <li> <p>If no movers are tracked, or no tracked movers have yet satisfied the objective, then .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT event logs. See Diagnostics &gt; ErrorMovers for more information.</p> </li> <li> <p>For this reason, it is recommended that all evaluations are nested inside IF checks for .MoverPassedPosition.</p> </li> <li> <p>It is possible that multiple registered movers have crossed over a threshold position. Only the most recently valid mover handle is provided by .CurrentMover.</p> <ul> <li>You must compare your PLC scan time, maximum mover velocity and minimum mover gap to ensure that all movers can be detected at a position trigger regardless of their velocity.</li> </ul> </li> </ul>"},{"location":"CodeReference/Objects/PositionTrigger.html#position","title":".Position","text":"<p>LREAL</p> <p>Current placement of the Position Trigger threshold along the track</p>"},{"location":"CodeReference/Objects/PositionTrigger.html#track","title":".Track","text":"<p>REFERENCE TO Track</p> <p>Track that the station is assigned to when using track management. See the Track object.</p>"},{"location":"CodeReference/Objects/PositionTrigger.html#triggerdirection","title":".TriggerDirection","text":"<p>Tc3_Mc3Definitions.MC_Direction</p> <p>Sets the direction of travel required for the mover to trigger the position trigger.</p> <p>Options are:</p> <ul> <li>MC_PositiveDirection: The mover's position is increasing as it crosses the trigger. (Default)</li> <li>MC_Negative_Direction: The mover's position is decreasing as it crosses the trigger.</li> </ul>"},{"location":"CodeReference/Objects/PositionTrigger.html#statistics","title":".Statistics","text":"<p>A set of timers, counts and values that track the throughput of the position trigger and velocity of movers at the trigger.</p> Member Type Description InterarrivalTime TIME Current amount of time between mover events LatestMoverVelocity LREAL Mover velocity of the most-recent trigger event InterarrivalTimeHistory ARRAY[0..63] OF TIME Ring buffer of recent interarrival times MoverVelocityHistory ARRAY[0..63] OF LREAL Ring buffer of recent mover velocities AverageInterarrivalTime TIME Average of all nonzero Interarrival times in the ring buffer AverageMoverVelocity LREAL Average of all nonzero mover velocities in the ring buffer AverageMoversPerMinute LREAL; ProcessedMoverCount UDINT Total number of movers processed by this position trigger"},{"location":"CodeReference/Objects/PositionTrigger.html#extra-examples","title":"Extra Examples","text":"<pre><code>// Basic Position Trigger implementation\n\n// Begin monitoring Mover 1\nIF bInit THEN\n    Mover[1].MoveToPosition( 1000 );\n    PositionTrigger.Position    := 800;\n    PositionTrigger.RegisterMover( Mover[1] );\n    bInit   := FALSE;\nEND_IF\n\n// When Mover 1 crosses position 800, slow it down to 100mm/s\nIF PositionTrigger.MoverPassedPosition THEN\n    PositionTrigger.CurrentMover.SetVelocity( 100 );\n    // MuteCurrent clears MoverPassedPosition and CurrentMover so that\n    // Line 12 does not continually evaluate as true\n    PositionTrigger.MuteCurrent();\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Station.html","title":"Station Object","text":"<p>The Station object provides a fixed location for a Mover to stop at until it is ready to be released. A Station is a type of Objective, and provides a handle to the Mover object that is currently docked with the Station, allowing further motion commands to be issued to the Mover.</p>"},{"location":"CodeReference/Objects/Station.html#setup-execution","title":"Setup &amp; Execution","text":"<pre><code>// Declaration\nStation     : ARRAY [0..GVL.NUM_STATIONS-1] OF Station;\n</code></pre> <p><pre><code>// Initialization\nStation[1].Position     := 250;\nStation[2].Position     := 500;\nStation[3].Position     := 750;\n</code></pre> Stations must also be added to the Mediator object. By default, this is handled automatically.</p> <pre><code>// Example implementation\nMediator.AddStation( Station[1] );\n</code></pre>"},{"location":"CodeReference/Objects/Station.html#mover-registration","title":"Mover Registration","text":"<p>Unlike other types of Objectives, Stations manage mover registration automatically. Any mover that is commanded with a MoveToStation is also automatically registered with that station. As an example, this implementation would be redundant:</p> <pre><code>Mover[2].MoveToStation( Station[3] );\nStation[3].RegisterMover( Mover[2] );       // unnecessary\n</code></pre> <p>Stations also automatically unregister movers that have been redirected with another move command, even if that command's destination is the same location as the Station.</p> <pre><code>Mover[2].MoveToStation( Station[3] );\nMover[2].MoveToPosition( Station[3].Position );\n</code></pre> <p>Here, the Station will not report MoverInPosition when it arrives because the original command is interrupted by one where the CurrentMoveType is not <code>MOVETYPE_STATION</code>.</p>"},{"location":"CodeReference/Objects/Station.html#methods","title":"Methods","text":""},{"location":"CodeReference/Objects/Station.html#cyclic","title":"Cyclic","text":"<p>Cyclic()</p> <p>Stations require a cyclic call in the Main program. This allows the station to automatically unregister movers from its Tracked list who have been redirected and are no longer destined for this Station.</p> <p>The call to Cyclic() is handled automatically after the station has been registered with the Mediator.</p>"},{"location":"CodeReference/Objects/Station.html#reset-statistics","title":"Reset Statistics","text":"<p>ResetStatistics()</p> <p>Resets the Statistics for this station. See the Statistics property.</p>"},{"location":"CodeReference/Objects/Station.html#set-track","title":"Set track","text":"<p>SetTrack()</p> <pre><code>Station[1].Position := 1000.0;\nStation[1].SetTrack(Track[2]);\n</code></pre>"},{"location":"CodeReference/Objects/Station.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/Station.html#blocked","title":".Blocked","text":"<p>BOOL</p> <p>A station is considered blocked if a mover has left the station but that mover has not yet moved further than the mover's <code>.Gap</code>.</p> <p>This value is used internally to calculate some values in the <code>.Statistics</code> property by detecting when a station does not have a mover, but also can not receive a mover because of the gap maintained by collision avoidance.</p>"},{"location":"CodeReference/Objects/Station.html#currentmover","title":".CurrentMover","text":"<p>REFERENCE TO Mover</p> <p>Reference variable that refers to the Mover that is docked with the Station</p> <p>When no mover is present in the Station, .CurrentMover is an invalid reference. In this case, an ErrorMover will replace the invalid reference. The user will receive notifications when this happens in the TwinCAT Event Logs.</p> <p>It is recommended that all evaluations are nested inside IF checks for .MoverInPosition.</p>"},{"location":"CodeReference/Objects/Station.html#description","title":".Description","text":"<p>STRING</p> <p>A text description of the station that is passed to the visualization tools. It's also visible within within the TwinCAT debugging tools for easier identification of stations.</p> <p>This value can be changed at runtime and will update on the visualization. This offers the opportunity to put dynamic data on the XTS visualization such as a station part count.</p>"},{"location":"CodeReference/Objects/Station.html#groupsize","title":".GroupSize","text":"<p>DINT</p> <p>When multiple stations perform the same operation they are considered \"grouped\". This value represents the number of stations in the group.</p> <p>This value is only used to help calculate throughput <code>.Statistics</code> on the mover and is used in combination with the <code>.Blocked</code> property.</p>"},{"location":"CodeReference/Objects/Station.html#moverinposition","title":".MoverInPosition","text":"<p>BOOL</p> <p>Status boolean indicating that a mover is currently docked with the Station</p>"},{"location":"CodeReference/Objects/Station.html#trackedmovercount","title":".TrackedMoverCount","text":"<p>USINT</p> <p>Simply reports the number of Movers that are currently registered with the Station. Because Stations automatically deregister movers that are not currently destined for this Station, this value also represents the current number of incoming movers.</p> <p>Note</p> <p>This property is part of Objective but is frequently used with stations and can be accessed as part of the Station object.</p>"},{"location":"CodeReference/Objects/Station.html#position","title":".Position","text":"<p>LREAL</p> <p>Current placement of the Station along the track</p> <p>This value is also used to place a marker on the visualization tools representing the station. See Visualization.</p>"},{"location":"CodeReference/Objects/Station.html#statistics","title":".Statistics","text":"<p>A set of timers and counts that track the throughput and utilization of the station.</p> Member Type Description TimeOccupied TIME Current amount of time that the station has had a MoverInPosition TimeEmpty TIME Current amount of time where MoverInPosition is FALSE TimeBlocked TIME Current amount of time where station cannot receive a new mover because the previous mover has not moved far enough away from the station OccupiedTimeHistory ARRAY[0..63] OF TIME Ring buffer of recent TimeOccupied values EmptyTimeHistory ARRAY[0..63] OF TIME Ring buffer of recent TimeEmpty values BlockedTimeHistory ARRAY[0..63] OF TIME Ring buffer of recent TimeBlocked values AverageTimeOccupied TIME Average of all nonzero TimeOccupied values in the ring buffer AverageTimeEmpty TIME Average of all nonzero TimeEmpty values in the ring buffer AverageTimeBlocked TIME Average of all nonzero TimeBlocked values in the ring buffer AverageTimeBetweenMovers TIME Sum of average TimeOccupied + AverageTimeEmpty AverageUtilizationFactor LREAL Percentage value equal to AverageTimeOccupied / AverageTimeBetweenMovers AverageMoversPerMinute LREAL MPM Throughput value, equal to 60 / AverageTimeBetweenMovers [s] ThrottledThreshold LREAL A high throttled threshold (Blocked to Empty ratio) indicates a potential bottleneck station ProcessedMoverCount UDINT Total number of movers processed by this station"},{"location":"CodeReference/Objects/Station.html#track","title":".Track","text":"<p>REFERENCE TO Track</p> <p>Track that the station is assigned to when using track management. See the Track object.</p>"},{"location":"CodeReference/Objects/Station.html#trackid","title":".TrackId","text":"<p>DINT</p> <p>The numeric id of the track that this station is assigned to.</p> <p>This value is read-only. Use the method <code>.SetTrack()</code> to set the station's assigned track.</p>"},{"location":"CodeReference/Objects/Station.html#extra-examples","title":"Extra Examples","text":"<pre><code>// Basic Station implementation with a 1s dwell time\nIF Station[0].MoverInPosition THEN\n    StationTimer( IN := TRUE, PT := T#1000MS ); // TON\n\n    IF StationTimer.Q THEN\n        Station[0].CurrentMover.MoveToStation( Station[1] );\n    END_IF\nELSE\n    StationTimer( IN := FALSE );\nEND_IF\n</code></pre> <pre><code>// Immediately redirect all incoming shuttles to Station 1 instead of Station 0\nFOR i := 0 TO Station[0].TrackedMoverCount-1 DO\n    targetMover := Station[0].TrackedMovers[i];\n    targetMover^.MoveToStation( Station[1] );\nEND_FOR\n</code></pre>"},{"location":"CodeReference/Objects/Station.html#station-labeling-in-viewing-tools","title":"Station Labeling In Viewing Tools","text":"<p>See Visualization</p>"},{"location":"CodeReference/Objects/Track.html","title":"Track Object","text":"<p>The track object contains functionality used for track management (switching movers between different tracks). In includes functionality for:</p> <ul> <li>Assigning a user-friendly numerical TrackID for use in code</li> <li>Finding and addressing all movers on a track</li> <li>Checking the status of the track initialization</li> </ul>"},{"location":"CodeReference/Objects/Track.html#description","title":"Description","text":"<p>Tracks are a software defined group of motor modules that can be grouped together independently of the physical machine layout. Tracks allow you to switch movers between different groups of otherwise disconnected motor modules. A common use case is an oval system layout with a reject spur. Movers typically travel around the oval during normal production, but stop at a track \"switch\" which moves between the oval and a separate reject spur.  </p> <p>The track object is only necessary when using track management. For most applications that utilize a single, closed loop track the Track object does not need to be addressed directly. Movers, zones, stations and position triggers all reference a track internally but are set with defaults of TrackID 1 which is generated automatically by the configuration tool.</p>"},{"location":"CodeReference/Objects/Track.html#setup","title":"Setup","text":"<p>Tracks are declared as an array and should be numbered starting at 1 to match the numbering assigned by the XTS configurator. The provided code does this automatically and will find the correct hardware address for each track in the array during the initialization phase.</p> <p>Tracks must also be added to the Mediator object. By default, this is handled in the MAIN.Initialize ACTION</p> <pre><code>// Example implementation\nMediator.AddTrack( Track );\n</code></pre> <p>Important</p> <p>Tracks must receive their hardware ID from the XTS Processing Unit before they can be used. This is handled automatically by the <code>.Cyclic()</code> method but may take several PLC scans at startup before the track can be utilized in code. The property <code>.isInitialized</code> is provided to check that this process has been completed before using the track in code.</p>"},{"location":"CodeReference/Objects/Track.html#use","title":"Use","text":"<p>Tracks are used in three ways in software:</p> <ul> <li>Parameters to other objects</li> <li>Managing movers on a track</li> <li>Properties of a mover</li> </ul>"},{"location":"CodeReference/Objects/Track.html#tracks-as-parameters","title":"Tracks as parameters","text":"<p>When configuring a Station, Zone or Position trigger a TrackID can be attached to each. If you are not using track management, a default TrackID is assigned to these objects that will allow them to work without explicitly assigning a TrackID.</p> <p>Stations, Zones and Position Triggers will only return or act on movers that are assigned to the same track as the object's TrackId</p> <pre><code>// position trigger at 150.0 mm on track 2\nPositionTrigger[1].Position := 150.0;\nPositionTrigger[1].SetTrack(Track[2]);\n\n// Zone between 200.0 and 300.0 mm on track 3\nZone[1].StartPosition := 200.0;\nZone[1].EndPosition   := 200.0;\nZone[1].SetTrack(Track[3]);\n\n// Station at 250.0 mm on track 3\nStation[1].Position := 250.0;\nStation[1].SetTrack(Track[3]);\n</code></pre>"},{"location":"CodeReference/Objects/Track.html#tracks-managing-movers","title":"Tracks managing movers","text":"<p>Tracks maintain a MoverList that can be used to track and query the movers on the track. See the MoverList object for complete details. Some common use cases are shown below</p> <pre><code>// move all movers on track to a station\n// movers will queue at the station by using built-in collision avoidance\nTrack[1].CurrentMoverList.MoveAllToStation(Station[1]);\n\n// find the mover closest to a fixed position on this track and set the velocity\nTrack[1].CurrentMoverList.GetMoverByLocation(0, 150.0, MC_Positive_Direction).SetVelocity(500.0);\n\n// get the count of movers on this track\niMoverCount := Track[1].CurrentMoverCount;\n</code></pre>"},{"location":"CodeReference/Objects/Track.html#properties-of-a-mover","title":"Properties of a mover","text":"<p>Every mover is assigned to a track. Movers can only move to stations and positions on the track they are currently assigned to.</p> <p>See the property Mover for additional information.</p>"},{"location":"CodeReference/Objects/Track.html#mover-direction-considerations","title":"Mover Direction Considerations","text":"<p>When using tracks where some are closed loops (ovals) and others are not (spurs), it is important to pay attention to the direction mode of the mover with <code>Mover.SetDirection()</code>. By default this is set to <code>mcDirectionPositive</code> which works well for ovals and will automatically wrap positions (modulo) as the mover reaches the rollover point.</p> <p>When a non-closed section of track is used (such as a rework spur), the mover commands <code>Mover.MoveToPosition</code> and <code>Mover.MoveToStation</code> as well as the related commands in a <code>MoverList</code> do not work with the default direction. When a mover is switched to a non-closed track, <code>Mover.SetDirection(mcDirectionNonModulo)</code> should also be called to set the mover's positioning to absolute along this portion of the track. Then when transitioning back to a closed section of track <code>Mover.SetDirection(mcDirectionPositive)</code> should be called to revert to the default modulo operation.</p>"},{"location":"CodeReference/Objects/Track.html#methods","title":"Methods","text":"<p>The methods listed below are used internally within the base code and should not be called directly by the user. They are shown for completeness.</p>"},{"location":"CodeReference/Objects/Track.html#cyclic","title":"Cyclic","text":"<p>Handles the initialization of the Track object by finding its hardware OTCID.</p>"},{"location":"CodeReference/Objects/Track.html#registermover","title":"RegisterMover","text":"<p>RegisterMover( NewMover : REFERENCE TO Mover )</p> <p>This is used internally by Mover.Cyclic() to manage the list of movers associated with this track.</p>"},{"location":"CodeReference/Objects/Track.html#unregisterall","title":"UnregisterAll","text":"<p>UnregisterAll( )</p> <p>This is used internally by the Track Object</p>"},{"location":"CodeReference/Objects/Track.html#unregistermover","title":"UnregisterMover","text":"<p>unRegisterMover( RemovingMover : REFERENCE TO Mover)</p> <p>This is used internally by Mover.Cyclic() to manage the list of movers associated with this track.</p>"},{"location":"CodeReference/Objects/Track.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/Track.html#currentmoverlist","title":"CurrentMoverList","text":"<p>MoverList (Read Only)</p> <p>Provides a MoverList object reference, containing all Movers that are currently assigned to this track. As a MoverList, methods are provided to command all movers as a group. See MoverList for more information</p>"},{"location":"CodeReference/Objects/Track.html#currentmovercount","title":"CurrentMoverCount","text":"<p>DINT (Read Only)</p> <p>Returns the count of movers currently assigned to this track</p>"},{"location":"CodeReference/Objects/Track.html#id","title":"Id","text":"<p>DINT</p> <p>Stores the user-friendly numeric track identifier.</p> <p>This property is read/write, but should only be written once during initialization (handled by <code>MAIN.Registering()</code>) and should not change during execution. It is provided for querying and comparing TrackIds between objects.</p>"},{"location":"CodeReference/Objects/Track.html#otcid","title":"OTCID","text":"<p>OTCID</p> <p>Stores the hardware id of the track object found in XTSProcessingUnit 1</p> <p>This property is read/write, but should only be written once during initialization (handled by <code>.Cyclic()</code>) and should not change during execution. It is used internally by <code>Mover.ActivateTrack()</code>.</p> <p>By default during the initialization step all track OTCIDs are assigned automatically.</p>"},{"location":"CodeReference/Objects/Zone.html","title":"Zone Object","text":"<p>The Zone object provides a way to select all Movers within a specified geographic area on the track. A Zone is defined by a Start Position and an End Position, and returns every mover between these points. Zones are especially useful for programming recovery scenarios. When using track management, zones make use of TrackId and only return movers that are both within the zones defined geographic area and have a matching TrackId.</p>"},{"location":"CodeReference/Objects/Zone.html#setup-execution","title":"Setup &amp; Execution","text":"<p><pre><code>// Declaration\nZoneLeftSide        : Zone;\nZoneRightSide       : Zone;\n</code></pre> <pre><code>// Initialization\nZoneLeftSide.StartPosition  := 0;\nZoneLeftSide.EndPosition    := 2000;\n\nZoneRightSide.StartPosition := 2000;\nZoneRightSide.EndPosition   := 4000;\n</code></pre></p> <p>Zones must also be added to the Mediator object. By default, this is handled automatically.</p> <pre><code>// Example implementation\nMediator.AddZone( ZoneLeftSide );\nMediator.AddZone( ZoneRightSide );\n</code></pre>"},{"location":"CodeReference/Objects/Zone.html#methods","title":"Methods","text":""},{"location":"CodeReference/Objects/Zone.html#getmover","title":"GetMover","text":"<p>GetMover( Index : USINT, Direction : Tc2_MC2.MC_Direction) : REFERENCE TO Mover</p> <p>Provides a reference to the Mover that has n = Index movers between it and the end of the Zone specified by the Direction</p> <pre><code>// Selects the mover closest to the Zone's End Position\n// Then issues a motion command\nZoneLeftSide.GetMover( 1, MC_Positive_Direction ).MoveToPosition( 2000 );\n\n// Selects the fourth-closest mover to the Zone's Start Position\n// Then sets its velocity\nZoneRightSide.GetMover( 4, MC_Negative_Direction ).SetVelocity( 1200 );\n</code></pre>"},{"location":"CodeReference/Objects/Zone.html#set-track","title":"Set track","text":"<p>SetTrack()</p> <pre><code>Zone[1].StartPosition := 1000.0;\nZone[1].EndPosition := 500.0;\nZone[1].SetTrack(Track[2]);\n</code></pre>"},{"location":"CodeReference/Objects/Zone.html#properties","title":"Properties","text":""},{"location":"CodeReference/Objects/Zone.html#currentmovercount","title":".CurrentMoverCount","text":"<p>USINT</p> <p>Provides a count of the number of movers that are currently withing the boundaries set by Start Position and End Position.</p> <pre><code>IF Zone.CurrentMoverCount &lt; 3 THEN\n    // code to allow more movers into this zone\nEND_IF\n</code></pre>"},{"location":"CodeReference/Objects/Zone.html#currentmoverlist","title":".CurrentMoverList","text":"<p>MoverList</p> <p>Provides a MoverList object reference, containing all Movers that are currently within the boundaries set by Start Position and End Position. As a MoverList, methods are provided to command all movers as a group. See MoverList objective for more information</p> <pre><code>// Command all movers from position 0 through 2000 to Station#1\nZoneLeftSide.CurrentMoverList.MoveAllToStation( Station[1] );\n\n// Command all movers from position 2000 through 4000 to Station#2\nZoneRightSide.CurrentMoverList.MoveAllToStation( Station[2] );\n\n// Command the singular mover which is closest to the end of the zone to Station#3\nZone.CurrentMoverList.GetMoverByLocation(0,Zone.EndPosition,MC_Positive_Direction).MoveToStation( Station[3] );\n</code></pre>"},{"location":"CodeReference/Objects/Zone.html#endposition","title":".EndPosition","text":"<p>LREAL</p> <p>Defines the upper bound for the track region considered by the Zone object.</p>"},{"location":"CodeReference/Objects/Zone.html#startposition","title":".StartPosition","text":"<p>LREAL</p> <p>Defines the lower bound for the track region considered by the Zone object.</p>"},{"location":"CodeReference/Objects/Zone.html#track","title":".Track","text":"<p>REFERENCE TO Track</p> <p>Track that the station is assigned to when using track management. See the Track object.</p>"},{"location":"CodeReference/Objects/Zone.html#zonelength","title":".ZoneLength","text":"<p>LREAL</p> <p>Calculates the length of the defined zone, in millimeters.</p>"},{"location":"CodeReference/Objects/Zone.html#properties-provided-by-moverlist","title":"Properties provided by MoverList","text":"<p>Some properties provided by the MoverList and Objective have similar syntax but different meanings.</p> <pre><code>// returns the number of movers currently registered with the Zone\nZone.TrackedMoverCount;\n\n// returns the number of movers physically within the zone\nZone.CurrentMoverList.TrackedMoverCount;\nZone.CurrentMoverCount;\n</code></pre> <p>Take care when using these properties.</p>"},{"location":"Examples/StationRouting.html","title":"Station Routing","text":"<p>This example demonstrates the most basic Station to Station routing. There are two stations which dwell for a period of time before sending movers to the next station in the sequence</p> <pre><code>MS_RUN:     // ----------------------------------- OPERATING\n\n\n    // Station 0 Logic\n    IF Station[0].MoverInPosition THEN\n        StationTimer[0]( IN := TRUE, PT := T#1000MS );\n\n        IF StationTimer[0].Q THEN\n\n            Station[0].CurrentMover.SetVelocity( 500 );\n            Station[0].CurrentMover.MoveToStation( Station[1] );\n\n        END_IF\n    ELSE\n        // Reset the timer for the next mover\n        StationTimer[0]( IN := FALSE );\n    END_IF\n\n\n\n\n    // Station 1 Logic\n    IF Station[1].MoverInPosition THEN\n    StationTimer[1]( IN := TRUE, PT := T#2s );\n\n        IF StationTimer[1].Q THEN\n\n            // Same behavior as above, but utilizing method chaining\n            Station[1].CurrentMover.SetVelocity( 90 ).MoveToStation( Station[0] );\n\n        END_IF\n    ELSE\n        // Reset the timer for the next mover\n        StationTimer[1]( IN := FALSE );\n    END_IF\n</code></pre>"},{"location":"GettingStarted/1_Introduction.html","title":"Introduction","text":"<p>Welcome to the Documentation for the XTS Base Code, provided by Beckhoff USA.</p> <p>Within this page, you will find code reference documentation, implementation examples, and best-practices for implementing &amp; modifying the project for your application.</p> <p>You are invited to submit contributions, feature requests, bug reports, or join the conversation on our Github page. For direct Support, please reach out to your local Beckhoff office.</p>"},{"location":"GettingStarted/1_Introduction.html#additional-resources","title":"Additional Resources","text":"<ul> <li>Project Github</li> <li>Beckhoff XTS Page</li> <li>Beckhoff XTS Infosys</li> </ul> <p>Intended use</p> <p>This site serves as reference documentation for the XTS Base Project. This site is not intended as a complete training guide on the XTS system, and contains no information on the electrical or mechanical setup of the system.</p> <p>Disclaimer</p> <p>All sample code provided by Beckhoff Automation LLC are for illustrative purposes only and are provided \u201cas is\u201d and without any warranties, express or implied. Actual implementations in applications will vary significantly. Beckhoff Automation LLC shall have no liability for, and does not waive any rights in relation to, any code samples that it provides or the use of such code samples for any purpose.</p>"},{"location":"GettingStarted/2_FirstSteps.html","title":"First Steps","text":""},{"location":"GettingStarted/2_FirstSteps.html#project-requirements","title":"Project Requirements","text":"<p>For new projects, the latest versions of TwinCAT and XTS software should be utilized.</p> <p>All XTS projects will require:</p> <ul> <li>TF5850</li> <li>TF5410</li> </ul> <p>Requirement</p> <p>Project versions 2.0 and later require TwinCAT Build 4026</p>"},{"location":"GettingStarted/2_FirstSteps.html#running-the-code","title":"Running the Code","text":"<p>This project ships with a ready-to-run oval with a 4m track length and 6 movers that run in simulation mode on your PC, no XTS hardware is required. It can be run as-is for testing and learning purposes.</p>"},{"location":"GettingStarted/2_FirstSteps.html#load-and-activate","title":"Load and Activate","text":"<p>Open the project with TwinCAT. Then activate the configuration using the button on the toolbar.</p> <p></p> <p>Confirm that you want to activate the configuration and check the <code>Autostart PLC Boot Project(s)</code> option.</p> <p></p> <p>You may be prompted to activate a trial license by entering a Captcha. Enter this value to generate the trial license. The project has been designed to work within the limits of a trial license. This license will be valid for 7-days after which it can be renewed indefinitely using this same process.</p> <p></p> <p></p> <p>Finally select OK to <code>Restart TwinCAT System in Run Mode</code></p> <p>;</p> <p>Twincat should now be running and can be confirmed by the green icon in the lower right status bar.</p> <p></p>"},{"location":"GettingStarted/2_FirstSteps.html#operate-the-system","title":"Operate the System","text":"<p>To view the simulated system select <code>TwinCAT &gt; XTS &gt; XTS Tool Window</code>.</p> <p></p> <p>Then select the <code>Live View</code> button.</p> <p></p> <p>The movers will be idle at this point. To start the movers in motion open the PLC HMI screen at <code>Base Project &gt; PLC &gt; Main &gt; Main Project &gt; VISUs &gt; Controls</code>.</p> <p></p> <p>The Controls HMI and XTS Tool Window are both dockable windows, arrange them as you desire to view both simultaneously. Here they have been placed side-by-side.</p> <p></p> <p>To start the system first click <code>Enable</code> to turn on the Mover's servo closed loop control then <code>Start</code> to begin the motion sequence.</p> <p>The three speeds used in the prepared motion sequence can be edited using the text fields next to the control push buttons.</p>"},{"location":"GettingStarted/2_FirstSteps.html#project-customization","title":"Project Customization","text":"<p>The base project includes a simulated configuration for a 4m oval track and 6 movers. This will need to be modified to fit your application.</p>"},{"location":"GettingStarted/2_FirstSteps.html#configuring-xts-hardware","title":"Configuring XTS Hardware","text":"<p>In order to modify the program to fit a different track configuration, navigate to the XTS Tool Window.</p> <p></p> <p>Then launch the XTS Configurator and follow the prompts to configure your system.</p> <p>The configurator occasionally conflicts with existing settings in the project. To avoid this, it can help to delete the following prior to running the XTS Configurator:</p> <ul> <li>XtsProcessingUnit</li> <li>All Mover Axis Objects</li> <li>Existing XTS_Task</li> <li>Any hardware in the IO section.</li> </ul> <p></p>"},{"location":"GettingStarted/2_FirstSteps.html#initialization-settings","title":"Initialization Settings","text":"<p>Once your hardware configuration is set, you will need to change a few variable parameters in the code to match the system.</p> <p>Inside MOTION &gt; Objects &gt; Collision Avoidance (CA Group), set the Rail Length parameter to match your hardware.</p> <p></p> <p>Next, open the MAIN POU file within PLC and modify the number of movers in the XTS declaration <code>FB_XTS&lt;6&gt;</code> by changing the value in the brackets.</p> <p></p> <p>Next, check that each of your Axis objects are properly linked to a corresponding Mover object.</p> <p></p> <p>Lastly, open the XtsProcessingUnit within SYSTEM and verify that every setting here is correct</p> <p></p>"},{"location":"GettingStarted/3_DesignApproach.html","title":"Design Approach","text":""},{"location":"GettingStarted/3_DesignApproach.html#fundamentals","title":"Fundamentals","text":"<p>The core concept driving the project structure is that it is useful to address movers contextually as opposed to directly. With that mantra in mind, this code provides a suite of tools to:</p> <ol> <li>Select a subset of movers that satisfy certain conditions</li> <li>Issue high-level motion commands to those selected movers</li> </ol> <p>High level commands are provided as methods, like this:</p> <pre><code>Mover[1].Enable();\n        .Disable();\n        .MoveToPosition(targetPosition);\n        .MoveToStation(targetStation);\n        .SyncToAxis(...);\n        ...etc.\n</code></pre> <p>Loads of different motion methods are available. Generally these are wrappers for PLCopen function blocks, and follow patterns you'd expect from typical point-to-point motion programming. </p> <p>Let's look at a single command in more depth:</p> <pre><code>Station[2].Position     := 1200; // mm\n\nMover[1].MoveToStation( Station[2] );\n</code></pre> <p>Here, we select Mover[1], and issue it a command move to position 1200. We'll cover Stations in a bit.</p> <p>The code above functions as you would expect. Except, in this example we're directly addressing our mover. Instead, let's send this command to whichever mover is currently located at Station[1]:</p> <pre><code>Station[1].Position     := 600; // mm\nStation[2].Position     := 1200; // mm\n\nStation[1].CurrentMover.MoveToStation( Station[2] );\n</code></pre> <p>Here, Station[1].CurrentMover is a POINTER to whichever mover currently sits at this position. Now our command functions regardless of which specific mover arrives at the station. It might be Mover #1, or Mover #2. In many cases, we don't really care. Furthermore, this logic will work regardless of the number of movers configured on our track, whether it's 2 or 200.</p> <p>We missed one thing in the code above. We can't always guarantee that Station[2] actually has a mover docked. So we need to add a check:</p> <pre><code>Station[1].Position     := 600; // mm\n\n// Verify that a 'Current Mover' actually exists before commanding it\nIF Station[1].MoverInPosition THEN\n    Station[1].CurrentMover.MoveToStation( Station[2] );\nEND_IF\n</code></pre> <p>If we missed this addition, Station[1].CurrentMover could be a null pointer, and calling a method on this null pointer is bad.</p> <p>As you've seen, Stations provide access to any mover currently docked at the station's location. But there are other objects which can also be used to select movers based on context. Here is the complete list:</p> <ul> <li>Stations select a mover that is \"docked\" with the Station</li> <li>PositionTriggers select a registered mover that has \"crossed over\" the Trigger</li> <li>MoversLists select all registered movers that you assign to the List</li> <li>Zones select all registered movers that are contained within a defined region</li> </ul> <p>In addition to these selectors, it is even possible to select movers relative to other movers:</p> <pre><code>// Selects Mover[2]\nMover[1].NextMover...\n</code></pre> <p>Let's go a little further with our Station example:</p> <pre><code>Station[1].Position     := 600; // mm\nStation[2].Position     := 1200; // mm\n\nIF Station[1].MoverInPosition THEN\n    myTimer[1]( IN := TRUE, PT := t#2s );    \n    IF myTimer[1].Q THEN\n        Station[1].CurrentMover.MoveToStation( Station[2] );\n    END_IF;\nELSE\n    myTimer[1]( IN := FALSE );\nEND_IF;\n\nIF Station[2].MoverInPosition THEN\n    myTimer[2]( IN := TRUE, PT := t#2s );    \n    IF myTimer[2].Q THEN\n        Station[2].CurrentMover.MoveToStation( Station[1] );\n    END_IF;\nELSE\n    myTimer[2]( IN := FALSE );\nEND_IF;\n</code></pre> <p>Now, we've got two Stations where movers stop for 2 seconds, after which they recieve a command to release onwards to the other station. Now let's imagine we run this logic with 5 movers on a small track. For the majority of the cycle, 2 movers will be stopped at the stations while the other 3 are in-transit somewhere between them. This code will function successfully, because the movers are able to negotiate traffic without any additional input from you. This brings us to the next topic:</p>"},{"location":"GettingStarted/3_DesignApproach.html#collision-avoidance","title":"Collision Avoidance","text":"<p>Every motion command within this project implements Collision Avoidance. This feature is provided by TF5410.</p> <p>The functionality is simple: movers will attempt to complete their commands as directed, but will decelerate appropriately behind other movers like cars on the highway. This behavior is parameterizable:</p> <pre><code>Mover[1].MotionParameters.Gap       := 120;     // mm\n\nMover[1].MoveVelocity( 2000 );                  // mm/s\nMover[2].MoveVelocity( 100 );                   // mm/s\n</code></pre> <p>Here, Mover #1 is behind Mover #2, but commanded to move much faster. In this scenario Mover #1 will catch up to Mover #2 and follow along behind, leaving a center-to-center gap between the two of 120mm.</p> <p>Collision avoidance removes a significant amount of work for you, the developer. In the example below, a single command will send every mover on the track (regardless of the # of movers) to a Station. The first mover to arrive will \"dock\" with the station, and can be handled with code like the examples above. The rest of the movers will sit and wait patiently with a pending motion command. As soon as the first mover leaves the station, the queue indexes forward and the next mover in line docks with the station.</p> <pre><code>// Send every mover on the system to Station #4\nSystem.CompleteMoverList.MoveAllToStation( Station[4] );\n</code></pre>"},{"location":"GettingStarted/3_DesignApproach.html#registration","title":"Registration","text":"<p>Stations, Position Triggers, Zones, and MoverLists can only select (i.e. return) movers that have been Registered to them. Here's an example to illustrate:</p> <pre><code>Station[1].Position     := 500; // mm\n\nMover[1].MoveToPosition( 500 ); // mm\n\nStation[1].MoverInPosition; // will continue to return FALSE\n</code></pre> <p>In the example above, Mover #1 will arrive directly on top of the station, but Station[1].MoverInPosition will never return TRUE because the Mover was not explicitly sent to the Station.</p> <pre><code>Station[1].Position     := 500;\n\nMover[1].MoveToStation( Station[1] );\n\nStation[1].MoverInPosition; // will return TRUE once the mover arrives\n</code></pre> <p>Above, the command is an explicit directive. In this case, the .MoveToStation() command automatically registers the Mover with the Station.</p> <p>Manually managing registration is easy. These methods are common to Mover Lists, Position Triggers, Stations, and Zones:</p> <pre><code>// Manually register Movers #1-3 into a custom list\nmyMoverList.RegisterMover( Mover[1] );\nmyMoverList.RegisterMover( Mover[2] );\nmyMoverList.RegisterMover( Mover[3] );\n\n// Register Movers #1-3 with a position trigger via that list\nmyPositionTrigger.RegisterMoverList( myMoverList );\n\n// Manually unregister Mover #2. Movers #1 &amp; #3 remain.\nmyPositionTrigger.UnregisterMover( Mover[2] );\n\n// Manually unregister every mover from the custom list\nmyMoverList.UnregisterAll();\n\n// Or, do it from the Mover itself\nMover[3].UnregisterFromAll();\n</code></pre> <p>Much of this is done for you, automatically:</p> <ul> <li>Registration with Stations is automatically managed by the .MoveToStation method call</li> <li>Registration for Position Triggers occurs during initialization. By default, all movers are registered to all Position Triggers. Unregistering movers from Position Triggers can be done manually. If a mover is not registered with a Position Trigger, the trigger will completely ignore the mover.</li> <li>Registration for Zones occurs during initialization. By default, all movers are registered to all Zones. Unregistering movers from Zones can be done manually. If a mover is not registered with a Zone, the zone will never return that mover.</li> <li>Registration for MoverLists is entirely manual, by design.</li> </ul>"},{"location":"GettingStarted/3_DesignApproach.html#method-chaining","title":"Method Chaining","text":"<p>Most methods in the project return the current object itself, allowing for additional method calls on the same line of code. This approach is often referred to as a fluent interface. For example:</p> <pre><code>// All these method calls apply to Mover 1 in sequence\nMover[1].SetVelocity( 2000 ).SetAcceleration( 20000).MoveToPosition( 1000 );\n</code></pre> <p>In some cases, the order of the methods calls must be carefully considered. In the following example, the CurrentMover of Station #1 is commanded to move to Station #2. At this point, it is no longer considered the CurrentMover of Station #1. As a result, the SetVelocity method does not apply to the intended Mover object.</p> <pre><code>IF Station[1].MoverInPosition THEN\n    // The MoveToStation method returns an ErrorMover\n    // The SetVelocity method will not function correctly\n    Station[1].CurrentMover.MoveToStation(Station[2]).SetVelocity(1000);\nEND_IF;\n</code></pre> <p>However, the following example will work as intended:</p> <pre><code>IF Station[0].MoverInPosition THEN\n    // This line of code will function correctly\n    Station[0].CurrentMover.SetVelocity(1000).MoveToStation(Station[1]);\nEND_IF;\n</code></pre>"},{"location":"GettingStarted/4_ProjectTour.html","title":"Project Tour","text":""},{"location":"GettingStarted/4_ProjectTour.html#basics","title":"Basics","text":"<p>This project is roughly organized into Provided Objects and Implementation Placeholders.</p>"},{"location":"GettingStarted/4_ProjectTour.html#provided-objects","title":"Provided Objects","text":"<p>A suite of ready-to-use function blocks / objects are made available by this project and located in the \"XTS\" directory within the PLC project. These objects are:</p> <ul> <li>Mover</li> <li>MoverList</li> <li>PositionTrigger</li> <li>Station</li> <li>Track</li> <li>Zone</li> </ul> <p>Additionally there are three \"administrative\" object definitions which handle some of the background tasks &amp; quality-of-life enhancements. These include:</p> <ul> <li>Mediator</li> <li>ErrorMover</li> <li>Objective</li> </ul> <p>Finally, we provide a single function block / object which houses the rest:</p> <ul> <li>FB_XTS</li> </ul> <p>Detailed documentation for all of these objects is available in the Code Reference tab, above.</p> <p>Intent</p> <p>All of these objects are intended to be instantiated and used as-is without modifying their internal implementations- simply by calling the public methods and properties. However, for advanced solutions these objects are all provided completely open source for you to customize and extend as needed.</p>"},{"location":"GettingStarted/4_ProjectTour.html#implementation-placeholders","title":"Implementation Placeholders","text":"<p>A Main State Machine is provided in the MAIN (PRG). Underneath this POU are ACTIONS (Initializing, Recoverying, RecoverOneshot, and StationLogic), which can be places to add your application-specific logic. Some basic motion code is already included which makes this project ready-to-run, but the intent is for you to overwrite these sections according to your needs.</p> <p>The calling architecture itself is also an example, but can be manipulated to meet your organization's preferred coding methodology.</p>"},{"location":"GettingStarted/5_SystemRecovery.html","title":"System Recovery","text":"<p>System Recovery is the algorithm which takes the track from cold-and-dark and/or a faulted condition to a known state where your machine process can run.</p>"},{"location":"GettingStarted/5_SystemRecovery.html#goals","title":"Goals","text":"<ol> <li>Errors on the system should be reset &amp; cleared</li> <li>Conflicts &amp; collisions with other machinery should be cleared</li> <li>Considerations &amp; destinations for product WIP should be calculated</li> <li>Movers should move from any potential position to a known desired location &amp; status</li> </ol>"},{"location":"GettingStarted/5_SystemRecovery.html#general-approach","title":"General Approach","text":"<p>Two ACTIONS within the project (Recovery Oneshot and Recovering) are the implementation placeholders you can replace to build your specific recovery logic.</p> <p>RecoverOneshot is called once immediately after issuing the system start command. Common tasks in this section include sending all movers to a specified location or locations based on the current zone they reside in, or analyzing process data stored in non-volatile memory and sending movers to an appropriate location.</p> <p>Recovering is called cyclically after RecoverOneshot and continues to run until the <code>RecoveryComplete</code> bit has been set within the routine. A common task in this state is to wait for all movers to come to a standstill.</p> <p>It may also be necessary to extend the recovery portion of the state machine with additional steps. A common scenario with additional steps may include using the oneshot state to send robots and other tooling to clear positions, the first recovering state to wait for all tooling to be clear and an additional recovering_2 state to start the mover motion.</p> <p>Zones are a particularly useful tool during the recovery process.</p>"},{"location":"GettingStarted/5_SystemRecovery.html#special-considerations","title":"Special Considerations","text":"<p>If a mover is stopped in a station when the system is disabled, your recovery process will likely issue an explicit command for it to return to that station. A mover that is commanded to a position very close to its current position may exhibit unintuitive behavior, such as:</p> <ul> <li>The Mover makes a complete trip around the loop to reach the position</li> <li>The Mover backs up into the position, even though it was downstream of the target position and commanded with <code>mcDirectionPositive</code></li> <li>The Mover is showing an active motion command but does not move</li> </ul>"},{"location":"GettingStarted/5_SystemRecovery.html#mover-takes-a-complete-lap","title":"Mover Takes a Complete Lap","text":"<p>This will occur when the mover is downstream from the target position, even slightly. By default, Mover objects within the project move in the <code>mcDirectionPositive</code> direction, so if the mover is downstream of the commanded destination position, it will move downstream all the way around the system to complete the command.</p> <p>Movers will move slightly when disabled. Magnetic cogging forces create peaks &amp; valleys at the pitch of the stator coils and without active position control, the mover may tend to settle into these valleys.</p>"},{"location":"GettingStarted/5_SystemRecovery.html#mover-backs-up-into-position","title":"Mover Backs Up Into Position","text":"<p>In some scenarios, movers may move backwards to their destination position. This can occur even if the mover is downstream of the destination and set to <code>mcDirectionPositive</code>.</p> <p>This is due to an axis setting called Tolerance Window for Modulo Start which applies to modulo axes including XTS movers. A full discussion of this setting can viewed in Infosys (click).</p> <p></p>"},{"location":"GettingStarted/5_SystemRecovery.html#mover-shows-active-command-but-is-not-moving","title":"Mover Shows Active Command But Is Not Moving","text":"<p>This behavior is an extension of the example above with the addition of an immediately preceding mover.</p> <p>Consider a scenario with a Mover docked with a Station at Position 1000mm. Another mover waits according to Collision Avoidance with a 100mm gap at Position 900mm. The system is disabled, and the movers shift slightly to 1001mm and 902mm, respectively.</p> <p>Both movers recieve a MoveToStation recovery command to the same station at Position 1000mm. The leading mover is within the Tolerance Window for Modulo Start and thus attempts to move backwards. The trailing mover attempts to move forward. The distance between the movers is now 99mm, and Collision Avoidance prevents either mover from moving.</p> <p>Some resolutions to this can be explored and should be considered in the context of your entire process:</p> <ul> <li> <p>During recovery back up all movers by a small amount that is larger than the modulo start window.</p> </li> <li> <p>During regular processing use a staging location for the trailing mover that it outside the collision avoidance gap.</p> </li> <li> <p>During recovery, reduce the modulo start window to zero, forcing all movers to go forward only to their target position.</p> </li> <li> <p>During recovery, send all movers to a known starting location. Then distribute them from there to the necessary stations and processes.</p> </li> </ul>"},{"location":"GettingStarted/6_Visualization.html","title":"Visualization","text":"<p>Visualization of the XTS system without actual hardware or on an HMI in production can be accomplished in three ways.</p> <ul> <li>XTS Tool Window <p>available in dropdowns within XAE: TwinCAT &gt; XTS &gt; XTS Tool Window</p> </li> <li>XTS Viewer <p>external application available on the Windows Start Menu</p> </li> <li>TcHMI Package <p>A drop-in component available as a NuGet package in TcHMI</p> </li> </ul>"},{"location":"GettingStarted/6_Visualization.html#labeling-stations","title":"Labeling Stations","text":"<p>All three visualization tools allow for labeling stations to aid in following process flow during simulation, debugging, and production. The Station Name feature may need to be turned on in the settings window for any of these tools to get a display like the one shown below.</p> <p>By default this code will automatically use the first 10 stations and their <code>.Position</code> value to place markers. Stations are identified by a number that matches their index in the <code>MAIN.Station</code> array. However if a station's position value is 0.0 (and likely unused) it will be skipped by the station marker routine.</p> <p> </p>"},{"location":"GettingStarted/6_Visualization.html#customizing-station-names","title":"Customizing Station Names","text":"<p>The name associated with each station by default is the station's index in <code>MAIN.Station</code> however a more meaningful name can be assigned. In the Solution Explorer locate TcCOM objects under System and then expand the Info Server branch. Rename these objects to match station names such as those shown below. Note that ordering is important. The order of this list matches the indices in <code>MAIN.Station</code>. On larger systems we recommend keeping then number as well as adding a descriptive name to help keep this section easy to navigate.</p> <p></p>"},{"location":"GettingStarted/6_Visualization.html#adding-additional-stations","title":"Adding Additional Stations","text":"<p>By default the code is configured for 10 stations in <code>MAIN.Stations</code> and 10 matching stations in the Info Server. Every station being labeled needs a matching station in the info server. However the code will determine if not enough Info Server stations are available and only label those that are available.</p> <p>If you have increased the size of <code>MAIN.Stations</code> you should also consider increasing the number of stations in the Info Server to match. This allows all of them to have labels in the visualization tool. To add stations in the Solution Explorer locate TcCOM objects under System then expand the Info Server branch. Right click the info server branch and select Add New Item.</p> <p></p> <p>Then select XTS Modules &gt; XtsInfoServer. You may also enter the number of stations to add at the right using the Multiple field.</p> <p></p> <p>Finally, edit the names of the new stations either by continuing numbering or naming them as described in Customizing Station Names</p>"},{"location":"GettingStarted/6_Visualization.html#disabling-automatic-station-naming","title":"Disabling Automatic Station Naming","text":"<p>In more complex XTS systems and product flows the default station markers generated by the code may not be suitable, or you may have pre-defined stations using the XTS Configurator or manually with TcCOM objects. The station marker code will usually identify these pre-defined stations by looking for non-default values in the TcCOM objects and not overwrite them. But if necessary automatic naming of stations can be completely disabled by setting the the constant global variable <code>Param.AUTO_POPULATE_STATIONS</code> to <code>FALSE</code>.</p>"},{"location":"GettingStarted/6_Visualization.html#updating-and-refreshing-stations","title":"Updating and Refreshing Stations","text":"<p>Station markers are only generated the first time movers are enabled after a cold start (typically power on or activate).</p>"},{"location":"GettingStarted/6_Visualization.html#additional-documentation","title":"Additional Documentation","text":"<p>Documentation for the InfoServer and InfoServerStation object which is used by this code to mark stations is available on Infosys:</p> <ul> <li>InfoServer</li> <li>InfoStation</li> </ul>"},{"location":"GettingStarted/7_TipsRecommendations.html","title":"Programming Quick Tips","text":"<p>Here are a few quick tips to assist in developing with this project:</p> <ul> <li> <p>Methods are designed to be called once, not repeatedly.</p> </li> <li> <p>Collision avoidance should be the source of buffering, there should rarely be a reason for a buffer location to be user defined. </p> </li> <li> <p>Movers Contain an AxisRef. The status values of an AxisRef can be very useful. </p> </li> <li> <p>When using <code>.CurrentMover</code> properties (or similar), always wrap usage with a check for <code>.MoverInPosition</code> or similar, to verify that the pointers are valid. See <code>ErrorMovers</code> for more information.</p> </li> <li> <p>When reconfiguring the project for new hardware, be sure to delete elements of a previous configuration. More info on this is included in the First Steps section.</p> </li> <li> <p>When configuring new hardware, be sure that Is Closed and Is Included in Detection options are set correctly for tracks and parts.</p> </li> <li> <p>When programming recovery scenarios, be sure to unregister movers from objectives where necessary.</p> </li> </ul>"},{"location":"GettingStarted/7_TipsRecommendations.html#general-code-tips","title":"General Code Tips","text":"<p>More generally, here are some recommendations regarding the architecture of your solution:</p> <ul> <li> <p>Proper code should not depend on the number of movers added to the system, and should be easily scalable when movers are added or removed from the system. Directly addressing specific movers by ID should be avoided when possible. See Overview for more information.</p> </li> <li> <p>\"The fleet sails as fast as the slowest ship.\" Overall system throughput is governed by the slowest individual Station's throughput. Focus on understanding the limiting factors of your routing logic in order to optimize traffic flow. A Mover's maximum velocity rarely affects the overall system throughput.</p> </li> </ul>"},{"location":"GettingStarted/7_TipsRecommendations.html#common-issues","title":"Common issues","text":""},{"location":"GettingStarted/7_TipsRecommendations.html#changing-the-forward-direction-of-the-track","title":"Changing the forward direction of the track","text":"<p>Depending on the machine layout and the mounting needs of the motor modules the default direction of the track positions (clockwise for face-up motor modules) may not be desired. It is possible to invert the track's direction by changing the following settings.</p> <p>For each Track set in the XTS Processing Unit set <code>Parameter &gt; General &gt; Polarity</code> to <code>Negative</code>.</p> <p></p> <p>There are some additional considerations to be aware of when inverting the track direction, especially if the track direction is changed after portions of code have been written and tested.</p>"},{"location":"GettingStarted/7_TipsRecommendations.html#next-and-previous-movers","title":"Next and previous movers","text":"<p>When looking for the next and previous movers on a system, for example when working with 2-up stations, movers that have been referenced directly such as Mover[i] and Mover[i+1] may no longer be in the expected order. Functions such as <code>Mover.NextMover()</code>, <code>Mover.PreviousMover()</code> or <code>Zone.CurrentMoverList.GetMoverByLocation()</code> are the recommended methods. These methods will also handle an inverted track direction correctly.</p>"},{"location":"GettingStarted/GettingStarted.html","title":"First Steps","text":""},{"location":"GettingStarted/GettingStarted.html#project-requirements","title":"Project Requirements","text":"<p>For new projects, the latest versions of TwinCAT and XTS software should be utilized.</p> <p>All XTS projects will require:</p> <ul> <li>TF5850</li> <li>TF5410</li> </ul>"},{"location":"GettingStarted/GettingStarted.html#running-the-code","title":"Running the Code","text":"<p>This project ships with a ready-to-run oval with a 4m track length and 6 movers that run in simulation mode on your PC, no XTS hardware is required. It can be run as-is for testing and learning purposes.</p>"},{"location":"GettingStarted/GettingStarted.html#load-and-activate","title":"Load and Activate","text":"<p>Open the project with TwinCAT. Then activate the configuration using the button on the toolbar.</p> <p></p> <p>Confirm that you want to activate the configuration and check the <code>Autostart PLC Boot Project(s)</code> option.</p> <p></p> <p>You may be prompted to activate a trial license by entering a Captcha. Enter this value to generate the trial license. The project has been designed to work within the limits of a trial license. This license will be valid for 7-days after which it can be renewed indefinitely using this same process.</p> <p></p> <p></p> <p>Finally select OK to <code>Restart TwinCAT System in Run Mode</code></p> <p>;</p> <p>Twincat should now be running and can be confirmed by the green icon in the lower right status bar.</p> <p></p>"},{"location":"GettingStarted/GettingStarted.html#operate-the-system","title":"Operate the System","text":"<p>To view the simulated system select <code>TwinCAT &gt; XTS &gt; XTS Tool Window</code>.</p> <p></p> <p>Then select the <code>Live View</code> button.</p> <p></p> <p>The movers will be idle at this point. To start the movers in motion open the PLC HMI screen at <code>Base Project &gt; PLC &gt; Main &gt; Main Project &gt; VISUs &gt; Controls</code>.</p> <p></p> <p>The Controls HMI and XTS Tool Window are both dockable windows, arrange them as you desire to view both simultaneously. Here they have been placed side-by-side.</p> <p></p> <p>To start the system first click <code>Enable</code> to turn on the Mover's servo closed loop control then <code>Start</code> to begin the motion sequence.</p> <p>The three speeds used in the prepared motion sequence can be edited using the text fields next to the control push buttons.</p>"},{"location":"GettingStarted/GettingStarted.html#project-customization","title":"Project Customization","text":"<p>The base project includes a simulated configuration for a 4m oval track and 6 movers. This will need to be modified to fit your application.</p>"},{"location":"GettingStarted/GettingStarted.html#configuring-xts-hardware","title":"Configuring XTS Hardware","text":"<p>In order to modify the program to fit a different track configuration, navigate to the XTS Tool Window.</p> <p></p> <p>Then launch the XTS Configurator and follow the prompts to configure your system.</p> <p>The configurator occasionally conflicts with existing settings in the project. To avoid this, it can help to delete the following prior to running the XTS Configurator:</p> <ul> <li>XtsProcessingUnit</li> <li>All Mover Axis Objects</li> <li>Existing XTS_Task</li> <li>Any hardware in the IO section.</li> </ul> <p></p>"},{"location":"GettingStarted/GettingStarted.html#initialization-settings","title":"Initialization Settings","text":"<p>Once your hardware configuration is set, you will need to change a few variable parameters in the code to match the system.</p> <p>Inside MOTION &gt; Objects &gt; Collision Avoidance (CA Group), set the Rail Length parameter to match your hardware.</p> <p></p> <p>Next, open the MAIN Pout file within PLC and modify the number of movers in the XTS declaration <code>FB_XTS&lt;6&gt;</code> by changing the value in the brackets.</p> <p></p> <p>Next, check that each of your Axis objects are properly linked to a corresponding Mover object.</p> <p>!!! Note The project contains ErrorMover objects which also appear as options when linking axes. Do not link axes to these variables.</p> <p></p> <p>Lastly, open the XtsProcessingUnit within SYSTEM and verify that every setting here is correct</p> <p></p>"}]}